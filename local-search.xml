<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>nvim 一些重要 API</title>
    <link href="/2024/02/24/nvim-%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81-API/"/>
    <url>/2024/02/24/nvim-%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81-API/</url>
    
    <content type="html"><![CDATA[<p><a href="https://neovim.io/doc/user/api.html">nvim api</a> 是写插件必须要准备，这里总结一些经常遇到的一些 api，因为自己也是遇到了先去查文档。</p><p>这里会记录一些觉得使用频率较多的，记录一下。</p><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><h2 id="给-win-buf-设置-option"><a href="#给-win-buf-设置-option" class="headerlink" title="给 win &#x2F; buf 设置 option"></a>给 win &#x2F; buf 设置 option</h2><p>nvim_set_option_value({name}, {value}, {*opts})<br>Sets the value of an option. The behavior of this function matches that of :set: for global-local options, both the global and local value are set unless otherwise specified with {scope}.</p><p>Note the options {win} and {buf} cannot be used together.<br>Parameters:</p><ul><li>{name} Option name</li><li>{value} New option value</li><li>{opts} Optional parameters<ol><li>scope: One of “global” or “local”. Analogous to :setglobal and :setlocal, respectively.</li><li>win: window-ID. Used for setting window local option.</li><li>buf: Buffer number. Used for setting buffer local option.</li></ol></li></ul><blockquote><p>这个 api 是 nvim-10 新增的，用来代替 nvim_buf_set_option 和 nvim_win_set_option</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">vim.api.nvim_set_option_value(<span class="hljs-string">&quot;bufhidden&quot;</span>, <span class="hljs-string">&quot;delete&quot;</span>, &#123; buf = <span class="hljs-built_in">self</span>.bufnr &#125;)<br>vim.api.nvim_set_option_value(<span class="hljs-string">&quot;winfixwidth&quot;</span>, <span class="hljs-literal">true</span>, &#123; win = <span class="hljs-built_in">self</span>.winnr &#125;)<br>vim.api.nvim_set_option_value(<span class="hljs-string">&quot;modifiable&quot;</span>, <span class="hljs-literal">false</span>, &#123; buf = <span class="hljs-built_in">self</span>.bufnr &#125;)<br>vim.api.nvim_set_option_value(<span class="hljs-string">&quot;ft&quot;</span>, <span class="hljs-string">&quot;BufmsgHelp&quot;</span>, &#123; buf = <span class="hljs-built_in">self</span>.bufnr &#125;)<br></code></pre></td></tr></table></figure><h2 id="删除-buffer"><a href="#删除-buffer" class="headerlink" title="删除 buffer"></a>删除 buffer</h2><p>nvim_buf_delete(<code>&#123;buffer&#125;</code>, <code>&#123;*opts&#125;</code>) <code>nvim_buf_delete()</code>Deletes the buffer. See <a href="https://neovim.io/doc/user/windows.html#%3Abwipeout">:bwipeout</a></p><p>Attributes:<br>not allowed when <a href="https://neovim.io/doc/user/eval.html#textlock">textlock</a> is active or in the <a href="https://neovim.io/doc/user/cmdline.html#cmdwin">cmdwin</a></p><p>Parameters:<br><code>&#123;buffer&#125;</code> Buffer handle, or 0 for current buffer<br><code>&#123;opts&#125;</code> Optional parameters. Keys:<br>force: Force deletion and ignore unsaved changes.<br>unload: Unloaded only, do not delete. See <a href="https://neovim.io/doc/user/windows.html#%3Abunload">:bunload</a></p><h2 id="创建-buffer"><a href="#创建-buffer" class="headerlink" title="创建 buffer"></a>创建 buffer</h2><p>nvim_create_buf(<code>&#123;listed&#125;</code>, <code>&#123;scratch&#125;</code>) <code>nvim_create_buf()</code>Creates a new, empty, unnamed buffer.<br>Parameters: (布尔值)<br><code>&#123;listed&#125;</code> Sets <a href="https://neovim.io/doc/user/options.html#'buflisted'">‘buflisted’</a><br><code>&#123;scratch&#125;</code> Creates a “throwaway” <a href="https://neovim.io/doc/user/windows.html#scratch-buffer">scratch-buffer</a> for temporary work (always <a href="https://neovim.io/doc/user/options.html#'nomodified'">‘nomodified’</a>). Also sets <a href="https://neovim.io/doc/user/options.html#'nomodeline'">‘nomodeline’</a> on the buffer.</p><p>Return:<br>Buffer handle, or 0 on error<br>See also:<br>buf_open_scratch</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.bufnr = vim.api.nvim_create_buf(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)<br>vim.api.nvim_set_option_value(<span class="hljs-string">&quot;bufhidden&quot;</span>, <span class="hljs-string">&quot;delete&quot;</span>, &#123; buf = <span class="hljs-built_in">self</span>.bufnr &#125;)<br></code></pre></td></tr></table></figure><p>‘buflisted’ ‘bl’boolean(default on)<br>            local to buffer<br>    When this option is set, the buffer shows up in the buffer list.  If<br>    it is reset it is not used for “:bnext”, “ls”, the Buffers menu, etc.<br>    This option is reset by Vim for buffers that are only used to remember<br>    a file name or marks.  Vim sets it when starting to edit a buffer.<br>    But not when moving to a buffer with “:buffer”.</p><h2 id="buffer-mapping"><a href="#buffer-mapping" class="headerlink" title="buffer mapping"></a>buffer mapping</h2><p>nvim_buf_set_keymap(<code>&#123;buffer&#125;</code>, <code>&#123;mode&#125;</code>, <code>&#123;lhs&#125;</code>, <code>&#123;rhs&#125;</code>, <code>&#123;*opts&#125;</code>) Sets a buffer-local <a href="https://neovim.io/doc/user/map.html#mapping">mapping</a> for the given mode.</p><p>Parameters:</p><p><code>&#123;buffer&#125;</code> Buffer handle, or 0 for current buffer</p><p>See also:</p><p><a href="https://neovim.io/doc/user/api.html#nvim_set_keymap()">nvim_set_keymap()</a></p><h2 id="buffer-插入-更新-文字"><a href="#buffer-插入-更新-文字" class="headerlink" title="buffer 插入&#x2F;更新 文字"></a>buffer 插入&#x2F;更新 文字</h2><h3 id="1-nvim-buf-set-lines-设置文字，行文本，index-从0开始"><a href="#1-nvim-buf-set-lines-设置文字，行文本，index-从0开始" class="headerlink" title="1. nvim_buf_set_lines 设置文字，行文本，index 从0开始"></a>1. nvim_buf_set_lines 设置文字，行文本，index 从0开始</h3><blockquote><p>如果 <code>start == end</code>，在该行开始 insert 文本<br>如果 <code>start == end+1</code>，在该行开始 insert 文本<br>如果 <code>start &gt;= end+2</code>，替换文本</p></blockquote><p>nvim_buf_set_lines({buffer}, {start}, {end}, {strict_indexing}, {replacement}) Sets (replaces) a line-range in the buffer.</p><p>Indexing is zero-based, end-exclusive. Negative indices are interpreted as length+1+index: -1 refers to the index past the end. So to change or delete the last element use start&#x3D;-2 and end&#x3D;-1.<br>To insert lines at a given index, set start and end to the same index. To delete a range of lines, set replacement to an empty array.<br>Out-of-bounds indices are clamped to the nearest valid value, unless strict_indexing is set.</p><h3 id="2-nvim-put-put"><a href="#2-nvim-put-put" class="headerlink" title="2. nvim_put (:put)"></a>2. nvim_put (:put)</h3><p>nvim_put(<code>&#123;lines&#125;</code>, <code>&#123;type&#125;</code>, <code>&#123;after&#125;</code>, <code>&#123;follow&#125;</code>) <code>nvim_put()</code>Puts text at cursor, in any mode.</p><p>Compare <a href="https://neovim.io/doc/user/change.html#%3Aput">:put</a> and <a href="https://neovim.io/doc/user/change.html#p">p</a> which are always linewise.</p><p>Attributes:<br>not allowed when <a href="https://neovim.io/doc/user/eval.html#textlock">textlock</a> is active</p><p>Parameters:<br><code>&#123;lines&#125;</code> <a href="https://neovim.io/doc/user/builtin.html#readfile()">readfile()</a>-style list of lines. <a href="https://neovim.io/doc/user/channel.html#channel-lines">channel-lines</a><br><code>&#123;type&#125;</code> Edit behavior: any <a href="https://neovim.io/doc/user/builtin.html#getregtype()">getregtype()</a> result, or:<br>“b” <a href="https://neovim.io/doc/user/visual.html#blockwise-visual">blockwise-visual</a> mode (may include width, e.g. “b3”)<br>“c” <a href="https://neovim.io/doc/user/motion.html#charwise">charwise</a> mode<br>“l” <a href="https://neovim.io/doc/user/motion.html#linewise">linewise</a> mode<br>“” guess by contents, see <a href="https://neovim.io/doc/user/builtin.html#setreg()">setreg()</a><br><code>&#123;after&#125;</code> If true insert after cursor (like <a href="https://neovim.io/doc/user/change.html#p">p</a>), or before (like <a href="https://neovim.io/doc/user/change.html#P">P</a>).<br><code>&#123;follow&#125;</code> If true place cursor at end of inserted text.</p><h3 id="3-nvim-buf-set-text-可以设置列"><a href="#3-nvim-buf-set-text-可以设置列" class="headerlink" title="3. nvim_buf_set_text 可以设置列"></a>3. nvim_buf_set_text 可以设置列</h3><p>nvim_buf_set_text(<code>&#123;buffer&#125;</code>, <code>&#123;start_row&#125;</code>, <code>&#123;start_col&#125;</code>, <code>&#123;end_row&#125;</code>, <code>&#123;end_col&#125;</code>, <code>&#123;replacement&#125;</code>) Sets (replaces) a range in the buffer<br>This is recommended over <a href="https://neovim.io/doc/user/api.html#nvim_buf_set_lines()">nvim_buf_set_lines()</a> when only modifying parts of a line, as extmarks will be preserved on non-modified parts of the touched lines.<br>Indexing is zero-based. Row indices are end-inclusive, and column indices are end-exclusive.<br>To insert text at a given <code>(row, column)</code> location, usestart_row &#x3D; end_row &#x3D; row<code>and</code>start_col &#x3D; end_col &#x3D; col<code>. To delete the text in a range, use </code>replacement &#x3D; {}&#96;.<br>Prefer <a href="https://neovim.io/doc/user/api.html#nvim_buf_set_lines()">nvim_buf_set_lines()</a> if you are only adding or deleting entire lines.<br>Prefer <a href="https://neovim.io/doc/user/api.html#nvim_put()">nvim_put()</a> if you want to insert text at the cursor position.</p><p>Attributes:</p><p>not allowed when <a href="https://neovim.io/doc/user/eval.html#textlock">textlock</a> is active</p><p>Parameters:<br><code>&#123;buffer&#125;</code> Buffer handle, or 0 for current buffer<br><code>&#123;start_row&#125;</code> First line index<br><code>&#123;start_col&#125;</code> Starting column (byte offset) on first line<br><code>&#123;end_row&#125;</code> Last line index, inclusive<br><code>&#123;end_col&#125;</code> Ending column (byte offset) on last line, exclusive<br><code>&#123;replacement&#125;</code> Array of lines to use as replacement</p><p>See also:<br><a href="https://neovim.io/doc/user/api.html#nvim_buf_set_lines()">nvim_buf_set_lines()</a><br><a href="https://neovim.io/doc/user/api.html#nvim_put()">nvim_put()</a></p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="创建一个window-可以是-split-或者是-float-windows"><a href="#创建一个window-可以是-split-或者是-float-windows" class="headerlink" title="创建一个window 可以是 split 或者是 float windows"></a>创建一个window 可以是 split 或者是 float windows</h2><p>此api可以创建一个新的window，这个文档太多了，具体参数还是看网页链接<br><a href="https://neovim.io/doc/user/api.html#nvim_open_win()">nvim_open_win</a></p><p>nvim_open_win(<code>&#123;buffer&#125;</code>, <code>&#123;enter&#125;</code>, <code>&#123;*config&#125;</code>) <code>nvim_open_win()</code>Opens a new split window, or a floating window if <code>relative</code> is specified, or an external window (managed by the UI) if <code>external</code> is specified.<br>Floats are windows that are drawn above the split layout, at some anchor position in some other window. Floats can be drawn internally or by external GUI with the <a href="https://neovim.io/doc/user/ui.html#ui-multigrid">ui-multigrid</a> extension. External windows are only supported with multigrid GUIs, and are displayed as separate top-level windows.<br>For a general overview of floats, see <a href="https://neovim.io/doc/user/api.html#api-floatwin">api-floatwin</a>.<br>The <code>width</code> and <code>height</code> of the new window must be specified when opening a floating window, but are optional for normal windows.</p><p>Example (Lua): window-relative float</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">vim.api.nvim_open_win(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>,<br>  &#123;relative=<span class="hljs-string">&#x27;win&#x27;</span>, row=<span class="hljs-number">3</span>, col=<span class="hljs-number">3</span>, width=<span class="hljs-number">12</span>, height=<span class="hljs-number">3</span>&#125;)<br></code></pre></td></tr></table></figure><p>Example (Lua): buffer-relative float (travels as buffer is scrolled)</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">vim.api.nvim_open_win(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>,<br>  &#123;relative=<span class="hljs-string">&#x27;win&#x27;</span>, width=<span class="hljs-number">12</span>, height=<span class="hljs-number">3</span>, bufpos=&#123;<span class="hljs-number">100</span>,<span class="hljs-number">10</span>&#125;&#125;)<br></code></pre></td></tr></table></figure><p>Example (Lua): vertical split left of the current window</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">vim.api.nvim_open_win(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, &#123;<br>  split = <span class="hljs-string">&#x27;left&#x27;</span>,<br>  win = <span class="hljs-number">0</span><br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="Autocmd"><a href="#Autocmd" class="headerlink" title="Autocmd"></a>Autocmd</h1><h1 id="创建-autocmd"><a href="#创建-autocmd" class="headerlink" title="创建 autocmd"></a>创建 autocmd</h1><p>nvim_create_autocmd(<code>&#123;event&#125;</code>, <code>&#123;*opts&#125;</code>) <code>nvim_create_autocmd()</code>Creates an <a href="https://neovim.io/doc/user/autocmd.html#autocommand">autocommand</a> event handler, defined by <code>callback</code> (Lua function or Vimscript function name string) or <code>command</code> (Ex command string).</p><p>Example using Lua callback:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">vim.api.nvim_create_autocmd(&#123;<span class="hljs-string">&quot;BufEnter&quot;</span>, <span class="hljs-string">&quot;BufWinEnter&quot;</span>&#125;, &#123;<br>  pattern = &#123;<span class="hljs-string">&quot;*.c&quot;</span>, <span class="hljs-string">&quot;*.h&quot;</span>&#125;,<br>  callback = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ev)</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;event fired: %s&#x27;</span>, vim.inspect(ev)))<br>  <span class="hljs-keyword">end</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>Example using an Ex command as the handler:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">vim.api.nvim_create_autocmd(&#123;<span class="hljs-string">&quot;BufEnter&quot;</span>, <span class="hljs-string">&quot;BufWinEnter&quot;</span>&#125;, &#123;<br>  pattern = &#123;<span class="hljs-string">&quot;*.c&quot;</span>, <span class="hljs-string">&quot;*.h&quot;</span>&#125;,<br>  command = <span class="hljs-string">&quot;echo &#x27;Entering a C or C++ file&#x27;&quot;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><p>[Note:](<a href="https://github.com/neovim/neovim/issues/new?labels=bug&title=user+docs+HTML:+api.txt+&body=%60gen_help_html.lua%60+problem+at:+https://neovim.io/doc/user/api.html">https://github.com/neovim/neovim/issues/new?labels=bug&amp;title=user+docs+HTML%3A+api.txt+&amp;body=`gen_help_html.lua`+problem+at%3A+https://neovim.io/doc/user/api.html</a> +unhandled+token%3A+<code>note</code> Context%3A <code>       &#125;) &lt;     Note%3A `pattern` is NOT automatically expanded (unlike with |%3Aautocmd|)%2C    thus names like &quot;%24HOME&quot; and &quot;~&quot; must be expanded explicitly%3A &gt;lua        pattern %3D vim.fn.expand(&quot;~&quot;) .. &quot;%2Fsome%2Fpath%2F*.py&quot; &lt;</code>) <code>pattern</code> is NOT automatically expanded (unlike with <a href="https://neovim.io/doc/user/autocmd.html#%3Aautocmd">:autocmd</a>), thus names like “$HOME” and “~” must be expanded explicitly:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">pattern = vim.fn.expand(<span class="hljs-string">&quot;~&quot;</span>) .. <span class="hljs-string">&quot;/some/path/*.py&quot;</span><br></code></pre></td></tr></table></figure><p>Parameters:</p><p><code>&#123;event&#125;</code> (string|array) Event(s) that will trigger the handler (<code>callback</code> or <code>command</code>).</p><p><code>&#123;opts&#125;</code> Options dict:</p><p>group (string|integer) optional: autocommand group name or id to match against.</p><p>pattern (string|array) optional: pattern(s) to match literally <a href="https://neovim.io/doc/user/autocmd.html#autocmd-pattern">autocmd-pattern</a>.</p><p>buffer (integer) optional: buffer number for buffer-local autocommands <a href="https://neovim.io/doc/user/autocmd.html#autocmd-buflocal">autocmd-buflocal</a>. Cannot be used with <code>&#123;pattern&#125;</code>.</p><p>desc (string) optional: description (for documentation and troubleshooting).</p><p>callback (function|string) optional: Lua function (or Vimscript function name, if string) called when the event(s) is triggered. Lua callback can return a truthy value (not <code>false</code> or <code>nil</code>) to delete the autocommand. Receives a table argument with these keys:</p><blockquote><p>还有一些不常用到的，可以看一下<a href="https://neovim.io/doc/user/api.html#nvim_create_autocmd()">链接</a></p></blockquote><p>Autocommand id (number)</p><p>See also:</p><p><a href="https://neovim.io/doc/user/autocmd.html#autocommand">autocommand</a></p><p><a href="https://neovim.io/doc/user/api.html#nvim_del_autocmd()">nvim_del_autocmd()</a></p>]]></content>
    
    
    <categories>
      
      <category>Nvim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Rust模式匹配中的所有权问题</title>
    <link href="/2024/02/10/Rust%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%89%80%E6%9C%89%E6%9D%83%E9%97%AE%E9%A2%98/"/>
    <url>/2024/02/10/Rust%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E4%B8%AD%E6%89%80%E6%9C%89%E6%9D%83%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Rust中的模式简单概述"><a href="#Rust中的模式简单概述" class="headerlink" title="Rust中的模式简单概述"></a>Rust中的模式简单概述</h1><p>Rust 中的模式(<a href="https://doc.rust-lang.org/reference/patterns.html">Pattern</a>)是支撑 Rust 语法非常重要的一环. 其会用在:</p><ol><li><code>let</code> 声明</li><li>函数或者闭包的参数匹配</li><li><code>match</code>  表达式</li><li><code>if let</code>  表达式</li><li><code>while let</code> 表达式</li><li><code>for</code> 表达式</li></ol><div class="note note-primary">            <p>此般, 确实可以看出 模式(Pattern) 在 Rust 中确实是遍地开花了.</p>          </div><p>一个例子:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Car</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Computer</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>        name: <span class="hljs-type">String</span>,<br>        car: <span class="hljs-type">Option</span>&lt;Car&gt;,<br>        computer: <span class="hljs-type">Option</span>&lt;Computer&gt;,<br>        age: <span class="hljs-type">u8</span>,<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">person</span> = Person &#123;<br>        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;John&quot;</span>),<br>        car: <span class="hljs-title function_ invoke__">Some</span>(Car),<br>        computer: <span class="hljs-literal">None</span>,<br>        age: <span class="hljs-number">15</span>,<br>    &#125;;<br>    <span class="hljs-comment">// ===============================</span><br>    <span class="hljs-comment">// 一下模式匹配会进行一下作用:</span><br>    <span class="hljs-comment">// 1. 检验含有 Car 类型的 car 有值, 为 Some;</span><br>    <span class="hljs-comment">// 2. 判断 age 是不是在区间 [13, 19] 范围内;</span><br>    <span class="hljs-comment">// 3. 获取到 name 字段的引用, 并命名为 person_name;</span><br>    <span class="hljs-comment">// 4. 忽略其他的字段.</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span><br>        <span class="hljs-variable">Person</span> &#123;<br>            car: <span class="hljs-title function_ invoke__">Some</span>(_),<br>            age: person_age @ <span class="hljs-number">13</span>..=<span class="hljs-number">19</span>,<br>            name: <span class="hljs-keyword">ref</span> person_name,<br>            ..<br>        &#125; = person<br>    &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; has a car and is &#123;&#125; years old.&quot;</span>, person_name, person_age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模式匹配中的和所有权问题"><a href="#模式匹配中的和所有权问题" class="headerlink" title="模式匹配中的和所有权问题"></a>模式匹配中的和所有权问题</h1><p>模式匹配会转移所有权(即发生 <code>move</code>), 具体规则为:</p><ol><li>匹配 Copy 语义的结构, 不会发生所有权转移, 会 <code>copy</code> </li><li>匹配仅 Move 语义而非 Copy 的结构, 会发生所有权转移, 会 <code>move</code></li><li>匹配 Move 语义的含有 Copy 和 Move 的字段的结构体, 会发生部分所有权转移, 结构体部分赋值一样效果</li><li>可以使用 ref 关键字, 获取引用, 不会发生发生 <code>move</code></li><li>可以去模式匹配 &amp; 结构, 不会发生所有权转移.</li><li><code>_</code> 忽略匹配不会发生 Move 语义, 尽管没有实现 Copy 的类型.</li></ol><ul><li><p>匹配 Copy 语义的结构, 不会发生所有权转移, 会 <code>copy</code> </p><p>  <code>Option&lt;T&gt; , T: Copy</code> 可以直接模式匹配, 匹配后依然可以使用原来的值</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a;<br><span class="hljs-comment">// println!(&quot;&#123;:?&#125;&quot;, a);</span><br><span class="hljs-built_in">assert_eq!</span>(a, <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>));<br><span class="hljs-built_in">assert_eq!</span>(b, <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>));<br>                                             <br><span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">P</span> &#123;<br>    age: <span class="hljs-type">i32</span>,<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(P &#123; age: <span class="hljs-number">22</span> &#125;);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a;<br><span class="hljs-built_in">assert_eq!</span>(a, <span class="hljs-title function_ invoke__">Some</span>(P &#123; age: <span class="hljs-number">22</span> &#125;));<br><span class="hljs-built_in">assert_eq!</span>(b, <span class="hljs-title function_ invoke__">Some</span>(P &#123; age: <span class="hljs-number">22</span> &#125;));<br></code></pre></td></tr></table></figure></li><li><p>匹配 Move 语义的结构, 会发生所有权转移</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(Person &#123;<br>    name: <span class="hljs-string">&quot;ann&quot;</span>.<span class="hljs-title function_ invoke__">into</span>(),<br>    age: <span class="hljs-number">22</span>,<br>&#125;);<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(v) = a &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, v);<br>&#125;<br><span class="hljs-comment">// borrow of partially moved value: `a`</span><br><span class="hljs-comment">// ERROR:: 会发生部分所有权转移, 这时候不能在完全使用a了.</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, a);<br><br>--<br>error[E0382]: borrow of partially moved value: `a`<br>  -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">53</span>:<span class="hljs-number">22</span><br>   |<br><span class="hljs-number">49</span> |     <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(v) = a &#123;<br>   |                 - value partially moved here<br>...<br><span class="hljs-number">53</span> |     <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, a);<br>   |                      ^ value borrowed here after partial <span class="hljs-keyword">move</span><br>   |<br>   = note: partial <span class="hljs-keyword">move</span> occurs because value has <span class="hljs-keyword">type</span> `Person`, which does not implement th<br>e `<span class="hljs-built_in">Copy</span>` <span class="hljs-keyword">trait</span><br></code></pre></td></tr></table></figure></li><li><p>匹配 Move 语义的含有 Copy 和 Move 的字段的结构体,会发生部分所有权转移. 和结构体部分赋值一样.</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Person &#123;<br>    name: <span class="hljs-string">&quot;oliver&quot;</span>.<span class="hljs-title function_ invoke__">into</span>(),<br>    age: <span class="hljs-number">23</span>,<br>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">Person</span> &#123; name, age &#125; = a;<br>                              <br><span class="hljs-comment">// OK;</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, a.age);<br>                              <br><span class="hljs-comment">//ERROR:</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, a.name);<br></code></pre></td></tr></table></figure></li><li><p>可以使用 ref 关键字, 获取引用</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Person &#123;<br>    name: <span class="hljs-string">&quot;oliver&quot;</span>.<span class="hljs-title function_ invoke__">into</span>(),<br>    age: <span class="hljs-number">23</span>,<br>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">Person</span> &#123; <span class="hljs-keyword">ref</span> name, <span class="hljs-keyword">ref</span> age &#125; = a;<br><span class="hljs-comment">// OK, 使用ref后没有发生所有权move, 依然可以继续使用a</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, a);<br></code></pre></td></tr></table></figure>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(Person &#123;<br>    name: <span class="hljs-string">&quot;haha&quot;</span>.<span class="hljs-title function_ invoke__">into</span>(),<br>    age: <span class="hljs-number">23</span>,<br>&#125;);<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> p) = a &#123;&#125;<br><br><span class="hljs-comment">// OK, 使用ref后没有发生所有权move, 依然可以继续使用a</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, a);<br></code></pre></td></tr></table></figure>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> a &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">ref</span> p) =&gt; (),<br>    _ =&gt; (),<br>&#125;<br><span class="hljs-comment">// OK, 使用ref关键字后没有发生所有权move, 可以可以正常使用a</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, a);<br></code></pre></td></tr></table></figure></li><li><p>可以去模式匹配 &amp; 结构, 不会发生所有权转移.</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(Person &#123;<br>    name: <span class="hljs-string">&quot;haha&quot;</span>.<span class="hljs-title function_ invoke__">into</span>(),<br>    age: <span class="hljs-number">23</span>,<br>&#125;);<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(p) = &amp;a &#123;&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, a);<br>---<br>以上代码等价于 使用<span class="hljs-keyword">ref</span>关键字<br>---<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(Person &#123;<br>    name: <span class="hljs-string">&quot;haha&quot;</span>.<span class="hljs-title function_ invoke__">into</span>(),<br>    age: <span class="hljs-number">23</span>,<br>&#125;);<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> p) = a &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>_</code> 忽略匹配不会发生 Move 语义, 尽管没有实现 Copy 的类型.</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = (<span class="hljs-string">&quot;oliver&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">12</span>);<br><span class="hljs-keyword">let</span> (_, a) = t;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, t); <span class="hljs-comment">// 正确, _ 不会去匹配 String, 不会发生 Move</span><br>                                    <br><span class="hljs-keyword">let</span> (s, a) = t;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, t); <span class="hljs-comment">// 错误, s 会去匹配 String 类型的 oliver, 会发生部分 Move, t.0 不能在使用</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust模式匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust Trait Object(特征对象)</title>
    <link href="/2023/11/28/Rust-Trait-Object-%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/11/28/Rust-Trait-Object-%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>关于特征对象，其实是 Rust 中多态的一种具体表现形式。而多态和泛型是面向对象的重要范畴。这里主要说明 特征对象 部份，英文称为 Trait Object。</p><p><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20231128092513.png" alt="Rust 多态"></p><p>我们以下面代码为基础</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">u8</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;u8: &#123;&#125;&quot;</span>, *<span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;string: &#123;&#125;&quot;</span>, *<span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="静态分发是什么"><a href="#静态分发是什么" class="headerlink" title="静态分发是什么"></a>静态分发是什么</h1><p>要明白静态分发是什么，需要明白<code>分发</code>是什么，分发其实就是让编译器知道具体实际运行的类型。不是很好懂？举个例子，分发其实就是让编译器明白一个 Foo 对象，实际运行的是 u8 还是 String。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 impl Trait 进行静态分发</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">do_something</span>(x: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span>) &#123;<br>    x.<span class="hljs-title function_ invoke__">method</span>();<br>&#125;<br><br><span class="hljs-comment">// 使用 trait bound 进行静态分发</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">do_something2</span>&lt;T: Foo&gt;(x: T) &#123;<br>    x.<span class="hljs-title function_ invoke__">method</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>有人会觉得第二种是多态。您是对的。这就是一种加限制的多态。如果可以忽略多态带来的代码体积影响，如果多态可以解决问题，建议优选多态。</p></blockquote><h2 id="哪一种更常用呢？"><a href="#哪一种更常用呢？" class="headerlink" title="哪一种更常用呢？"></a>哪一种更常用呢？</h2><p>Rust 使用更多的是使用 Trait Bound 进行的分发，也建议优先这种，因为有可能有很多个 Trait Bound，可以使用 <code>where</code> 更形式化。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">do_something3</span>&lt;T&gt;(x: T)<br><span class="hljs-keyword">where</span><br>    T: Foo + Bar + Other_traits,<br>&#123;<br>    x.<span class="hljs-title function_ invoke__">method</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态分发优点"><a href="#静态分发优点" class="headerlink" title="静态分发优点"></a>静态分发优点</h2><ol><li>速度快。静态分发其实会给每个类型都产生一份代码，这个是在编译期可以完成的，因此没有任何运行时开销。</li><li>有些情况下，只能使用 Trait Bound &#x2F; 多态。是的，impl Trait 也不可以。比如有关联函数。</li><li>使用 <code>where</code> 会更简明和直观。</li></ol><h1 id="动态分发"><a href="#动态分发" class="headerlink" title="动态分发"></a>动态分发</h1><h2 id="静态分发失效"><a href="#静态分发失效" class="headerlink" title="静态分发失效"></a>静态分发失效</h2><p>动态分发要解决的问题就是在编译器不能解决的问题。编译器如果不能确定类型，就没有办法给每个子类型产生一份代码，静态分发也就失效了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// ERROR: 以下代码编译出错</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_foo</span>(name: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;u8&quot;</span> &#123;<br>        <span class="hljs-number">3</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-string">&quot;test string&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码就是典型的静态分发失效。因为不能在编译器定类型，产生额外的代码，这就是一份代码。</p><h2 id="动态分发解决问题"><a href="#动态分发解决问题" class="headerlink" title="动态分发解决问题"></a>动态分发解决问题</h2><h3 id="返回一个-Box"><a href="#返回一个-Box" class="headerlink" title="返回一个 Box"></a>返回一个 Box<dyn Trait></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_foo_dynamic_dispatch</span>(name: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Foo&gt; &#123;<br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;u8&quot;</span> &#123;<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;test string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>这里为什么不使用 &amp;dyn Foo，可以想一下 Rust 中的生命周期，每个引用都会有一个生命周期，这是返回一个局部变量的引用，一个生命周期错误。</p>          </div><h3 id="作为闭包参数"><a href="#作为闭包参数" class="headerlink" title="作为闭包参数"></a>作为闭包参数</h3><div class="note note-primary">            <p>Rust 闭包不支持泛型，因此只能使用动态转发类型</p>          </div><p>比如，使用 Rust 写一个和 Golang 一样的二分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">search</span> = |n: <span class="hljs-type">usize</span>, f: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>&gt;| &#123;<br>    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> l, <span class="hljs-keyword">mut</span> r) = (<span class="hljs-number">0</span>, n);<br>    <span class="hljs-keyword">while</span> l &lt; r &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> !<span class="hljs-title function_ invoke__">f</span>(mid) &#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="动态分发引来的问题"><a href="#动态分发引来的问题" class="headerlink" title="动态分发引来的问题"></a>动态分发引来的问题</h2><p>动态分发不常用，因为<code>泛型/Trait Bound</code> 可以更好的解决更多问题，如果使用了动态转发，那么之前写的函数都需要为了动态转发的 Box<dyn Trait>&#x2F;&amp;dyn Trait 做很多适配，这样会显得很乱。</p><p>比如一个 <code>Box&lt;dyn Foo&gt;</code> 转换为 <code>Box&lt;u8&gt;</code> 是需要 <code>unsafe</code>，并且是破坏性的。不要这样做。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>闭包参数</li><li>设计模式需要，返回一个 Trait 类型</li><li>待添加 ……</li></ol>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Github搭建免费图床</title>
    <link href="/2023/11/23/%E4%BD%BF%E7%94%A8Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/"/>
    <url>/2023/11/23/%E4%BD%BF%E7%94%A8Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<p>在写 Blog 时，一个图床是非常有必要的，尤其是在 Blog 上公网服务器时，一般免费可以使用 Github 等等，但是有个问题在国内需要一些魔法。但是总之是免费的，毕竟程序员总是会有些魔法的。</p><div class="note note-danger">            <p>一般来说，Github 是不会像 Gitee 一样背刺程序员的。如果真的不能使用了，可以将图片仓库下载下来，上传到自己的服务器上，然后使用替换命令把前缀替换掉，总之也不算麻烦。</p>          </div><h1 id="准备配置-picgo-core"><a href="#准备配置-picgo-core" class="headerlink" title="准备配置 picgo-core"></a>准备配置 picgo-core</h1><p>可以根据项目地址安装，安装无痛。 项目地址：<a href="https://github.com/PicGo/PicGo-Core">picgo-core</a></p><p>配置文件 <code>linux</code> 和 <code>macOS</code> 均为 <code>~/.picgo/config.json</code>。</p><p>需要提前生成一个新的项目仓库和生成一个 <code>token</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;picBed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;current&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;github&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;uploader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;github&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;smms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;github&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;repo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户名/仓库地址&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;branch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;master&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*******************************&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;customUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;picgoPlugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="图形界面-Picgo"><a href="#图形界面-Picgo" class="headerlink" title="图形界面 Picgo"></a>图形界面 Picgo</h2><p>如果不是很需要，可以不用安装这个软件，其实没有必要安装，使用 picgo-core 足够了。</p><h1 id="nvim-的-picgo-插件"><a href="#nvim-的-picgo-插件" class="headerlink" title="nvim 的 picgo 插件"></a>nvim 的 picgo 插件</h1><p>如果想体验在 vim 中写 Blog，然后截图到 剪贴板（clipboard），然后一键上传图床，在返回目标图片的地址，可以直接复制到 Blog 中。</p><p>可以使用此插件：<a href="https://github.com/askfiy/nvim-picgo">nvim-picgo</a></p><div class="note note-success">            <p>Happy Writting!!!</p>          </div>]]></content>
    
    
    
    <tags>
      
      <tag>善其事,利其器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmux vi-mode 下进行复制</title>
    <link href="/2023/11/23/tmux-%E5%A4%8D%E5%88%B6/"/>
    <url>/2023/11/23/tmux-%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>就像美国上将 麦克阿瑟 说过，tmux 下复制是一件不容易的事情，但有个前提，那就是不使用鼠标</p>          </div><h1 id="使用鼠标进行复制"><a href="#使用鼠标进行复制" class="headerlink" title="使用鼠标进行复制"></a>使用鼠标进行复制</h1><p>使用鼠标进行复制是很容易的，应为这种复制条件并不是 <code>tmux</code> 支持的，而是 <code>terminal</code> 支持的，也就是说选择一款比较好的 <code>ternimal</code> 可以使用鼠标选中，然后使用（<code>ctrl-shift-v/command-v</code>）复制。</p><h2 id="1-kitty"><a href="#1-kitty" class="headerlink" title="1.kitty"></a>1.kitty</h2><p>我是很喜欢 <code>kitty</code> 的，因为它在我实习时第一次拿 <code>mac</code> 配 <code>vim</code> 环境时提供了特别好的体验（之前我是用 <code>alacritty</code> 的）。<br>你想用 <code>kitty</code> 在 <code>tmux</code> 下选中，可以按住 <code>shift</code> 然后用鼠标进行选择文本，然后按 <code>ctrl-shift-v</code> 复制就好了。</p><p>具体想看 <code>kitty</code> 提供了哪些 <code>mouse</code> 的支持可以看这里：<a href="https://sw.kovidgoyal.net/kitty/overview/#mouse-features">click here</a></p><h2 id="2-alacritty"><a href="#2-alacritty" class="headerlink" title="2.alacritty"></a>2.alacritty</h2><p><code>alacritty</code> 是在 <code>terminal</code> 层面支持 <code>vi-mode</code> 的，只要在 <code>terminal</code> 层面进行选中就好了，具体可以查看文档。</p><h2 id="3-其他终端"><a href="#3-其他终端" class="headerlink" title="3.其他终端"></a>3.其他终端</h2><div class="note note-primary">            <p>麦克阿瑟 还说过，如果一个国家有枪，其他国家必定也会有枪。</p>          </div><p>其他终端可以查看相应的文档，应该都会支持的，如果没有，建议转 <code>kitty</code>，小猫咪不会让你失望的。</p><h1 id="重点：tmux-支持-copy"><a href="#重点：tmux-支持-copy" class="headerlink" title="重点：tmux 支持 copy"></a>重点：tmux 支持 copy</h1><ol><li><code>linux</code> 可以使用 <code>xlicp</code></li><li><code>mac</code> 可以使用自带的 <code>pbcopy</code>，和 <a href="https://github.com/ChrisJohnsen/tmux-MacOSX-pasteboard">reattach-to-user-namespace</a></li></ol><p>然后使用以下配置就好了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">bind-key -T copy-mode-vi v send-keys -X begin-selection<br>unbind -T copy-mode-vi Enter<br><br>if-shell <span class="hljs-string">&quot;uname | grep -q Darwin&quot;</span> &#123;<br>  bind-key -T copy-mode-vi <span class="hljs-string">&#x27;y&#x27;</span> send -X copy-pipe-and-cancel <span class="hljs-string">&#x27;reattach-to-user-namespace pbcopy&#x27;</span><br>  bind-key -T copy-mode-vi Enter send -X copy-pipe-and-cancel <span class="hljs-string">&#x27;reattach-to-user-namespace pbcopy&#x27;</span><br>&#125; &#123;<br>  bind-key -T copy-mode-vi <span class="hljs-string">&#x27;y&#x27;</span> send -X copy-pipe-and-cancel <span class="hljs-string">&#x27;xclip -in -selection clipboard&#x27;</span><br>  bind-key -T copy-mode-vi Enter send -X copy-pipe-and-cancel <span class="hljs-string">&#x27;xclip -in -selection clipboard&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>其实就是把一些关于 <code>copy</code> 的命令绑定到 <code>enter</code> 和 <code>y</code> 键上。</p>          </div>]]></content>
    
    
    
    <tags>
      
      <tag>善其事,利其器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC.1851.包含每个查询的最小区间</title>
    <link href="/2023/07/18/LC-1851-%E5%8C%85%E5%90%AB%E6%AF%8F%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/"/>
    <url>/2023/07/18/LC-1851-%E5%8C%85%E5%90%AB%E6%AF%8F%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/problems/minimum-interval-to-include-each-query/description/">题目链接</a> | <a href="https://leetcode.cn/contest/weekly-contest-239">第 239 场单周赛</a> | <a href="https://leetcode.cn/contest/weekly-contest-239/problems/minimum-interval-to-include-each-query/">Q4</a> | 难度:2286</p>          </div><details open=""><summary>题目描述</summary><p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> 表示第 <code>i</code> 个区间开始于 <code>left<sub>i</sub></code> 、结束于 <code>right<sub>i</sub></code>（包含两侧取值，<strong>闭区间</strong>）。区间的 <strong>长度</strong> 定义为区间中包含的整数数目，更正式地表达是 <code>right<sub>i</sub> - left<sub>i</sub> + 1</code> 。</p><p>再给你一个整数数组 <code>queries</code> 。第 <code>j</code> 个查询的答案是满足 <code>left<sub>i</sub> <= queries[j] <= right<sub>i</sub></code> 的 <strong>长度最小区间 <code>i</code> 的长度</strong> 。如果不存在这样的区间，那么答案是 <code>-1</code> 。</p><p>以数组形式返回对应查询的所有答案。</p><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]<strong>输出：</strong>[3,3,1,4]<strong>解释：</strong>查询处理如下：- Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。- Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。- Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。- Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]<strong>输出：</strong>[2,-1,4,6]<strong>解释：</strong>查询处理如下：- Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。- Query = 19：不存在包含 19 的区间，答案为 -1 。- Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。- Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>1 <= intervals.length <= 10<sup>5</sup></code></li>    <li><code>1 <= queries.length <= 10<sup>5</sup></code></li>    <li><code>queries[i].length == 2</code></li>    <li><code>1 <= left<sub>i</sub> <= right<sub>i</sub> <= 10<sup>7</sup></code></li>    <li><code>1 <= queries[j] <= 10<sup>7</sup></code></li></ul></details><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><ol><li>离线做法, 按照 queries 从小到大 顺序处理</li><li>把<code>intervals</code>(假设一个<code>interval [left, right]</code>)按照开始时间从小到大排序</li><li>对于一个 query, 把满足条件 <code>left &lt;= q</code> 的 intervals 都加入堆和平衡树中</li><li>堆按照 <code>right</code> 小顶堆</li><li>平衡树按照间隔大小</li><li>对于一个 query, 把满足条件 <code>right &lt; q</code> 的 intervals 都从堆中移除</li><li>把移除的堆中的间隔, 从平衡树中移除</li><li>平衡树若为空, 此 <code>query</code> 为 <code>-1</code>, 否则, 就是平衡树最左侧叶子节点</li></ol><blockquote><p>如果不知道在Golang中如何使用平衡树, 可以查看上一篇文章.</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details open="">  <summary>Golang</summary><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minInterval</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>, queries []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>ids := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(queries))<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ids &#123;<br>ids[i] = i<br>&#125;<br>sort.Slice(ids, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> queries[ids[i]] &lt; queries[ids[j]] &#125;)<br>sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>] &#125;)<br><br>comp := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a == b &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br>tree := redblacktree.NewWith(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">int</span> &#123;<br>ia, ib := a.(<span class="hljs-type">int</span>), b.(<span class="hljs-type">int</span>)<br>ra, rb := intervals[ia][<span class="hljs-number">1</span>]-intervals[ia][<span class="hljs-number">0</span>], intervals[ib][<span class="hljs-number">1</span>]-intervals[ib][<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> x := comp(ra, rb); x != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> x<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> comp(ia, ib)<br>&#125;<br>&#125;)<br><br>ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(queries))<br>h := <span class="hljs-built_in">make</span>(hp, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(intervals))<br>cur := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, id := <span class="hljs-keyword">range</span> ids &#123;<br>q := queries[id]<br><span class="hljs-keyword">for</span> cur &lt; <span class="hljs-built_in">len</span>(intervals) &amp;&amp; intervals[cur][<span class="hljs-number">0</span>] &lt;= q &#123;<br>heap.Push(&amp;h, node&#123;cur, intervals[cur][<span class="hljs-number">1</span>]&#125;)<br>tree.Put(cur, <span class="hljs-literal">true</span>)<br>cur++<br>&#125;<br><span class="hljs-keyword">for</span> h.Len() &gt; <span class="hljs-number">0</span> &amp;&amp; h[<span class="hljs-number">0</span>].r &lt; q &#123;<br>c := heap.Pop(&amp;h).(node).i<br>tree.Remove(c)<br>&#125;<br><span class="hljs-keyword">if</span> tree.Empty() &#123;<br>ans[id] = <span class="hljs-number">-1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c := tree.Left().Key.(<span class="hljs-type">int</span>)<br>ans[id] = intervals[c][<span class="hljs-number">1</span>] - intervals[c][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-keyword">type</span> (<br>node <span class="hljs-keyword">struct</span>&#123; i, r <span class="hljs-type">int</span> &#125;<br>hp   []node<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Len() <span class="hljs-type">int</span>              &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span>    &#123; <span class="hljs-keyword">return</span> h[i].r &lt; h[j].r &#125; <span class="hljs-comment">// &gt; means maximum heap</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Swap(i, j <span class="hljs-type">int</span>)         &#123; h[i], h[j] = h[j], h[i] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hp)</span></span> Push(v <span class="hljs-keyword">interface</span>&#123;&#125;)   &#123; *h = <span class="hljs-built_in">append</span>(*h, v.(node)) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hp)</span></span> Pop() (v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; a := *h; *h, v = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>], a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]; <span class="hljs-keyword">return</span> &#125;<br></code></pre></td></tr></table></figure></details><details open="">  <summary>Rust</summary><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::collections::&#123;BTreeSet, BinaryHeap&#125;;<br><span class="hljs-meta">#[derive(Clone, Copy, PartialEq, Eq)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    i: <span class="hljs-type">usize</span>,<br>    l: <span class="hljs-type">i32</span>,<br>    r: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialOrd</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">partial_cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;std::cmp::Ordering&gt; &#123;<br>        <span class="hljs-keyword">let</span> (a, b) = (<span class="hljs-keyword">self</span>.r - <span class="hljs-keyword">self</span>.l, other.r - other.l);<br>        <span class="hljs-keyword">if</span> a == b &#123;<br>            <span class="hljs-keyword">self</span>.i.<span class="hljs-title function_ invoke__">partial_cmp</span>(&amp;other.i)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            a.<span class="hljs-title function_ invoke__">partial_cmp</span>(&amp;b)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Ord</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> std::cmp::Ordering &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">partial_cmp</span>(other).<span class="hljs-title function_ invoke__">unwrap</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[derive(Clone, Copy, PartialEq, Eq)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HeapNode</span> &#123;<br>    i: <span class="hljs-type">usize</span>,<br>    r: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialOrd</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">HeapNode</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">partial_cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;std::cmp::Ordering&gt; &#123;<br>        <span class="hljs-comment">// self.r.partial_cmp(&amp;other.r)</span><br>        other.r.<span class="hljs-title function_ invoke__">partial_cmp</span>(&amp;<span class="hljs-keyword">self</span>.r)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Ord</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">HeapNode</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> std::cmp::Ordering &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">partial_cmp</span>(other).<span class="hljs-title function_ invoke__">unwrap</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">min_interval</span>(<span class="hljs-keyword">mut</span> intervals: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt;, queries: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ids</span> = (<span class="hljs-number">0</span>..queries.<span class="hljs-title function_ invoke__">len</span>()).collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;();<br>        ids.<span class="hljs-title function_ invoke__">sort_unstable_by</span>(|&amp;a, &amp;b| queries[a].<span class="hljs-title function_ invoke__">cmp</span>(&amp;queries[b]));<br>        intervals.<span class="hljs-title function_ invoke__">sort_unstable_by</span>(|a, b| a[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">cmp</span>(&amp;b[<span class="hljs-number">0</span>]));<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">h</span>: BinaryHeap&lt;HeapNode&gt; = BinaryHeap::<span class="hljs-title function_ invoke__">with_capacity</span>(intervals.<span class="hljs-title function_ invoke__">len</span>());<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tree</span>: BTreeSet&lt;TreeNode&gt; = BTreeSet::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ans</span> = <span class="hljs-built_in">vec!</span>[-<span class="hljs-number">1</span>; queries.<span class="hljs-title function_ invoke__">len</span>()];<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">id</span> <span class="hljs-keyword">in</span> ids &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = queries[id];<br>            <span class="hljs-keyword">while</span> cur &lt; intervals.<span class="hljs-title function_ invoke__">len</span>() &amp;&amp; intervals[cur][<span class="hljs-number">0</span>] &lt;= q &#123;<br>                h.<span class="hljs-title function_ invoke__">push</span>(HeapNode &#123;<br>                    i: cur,<br>                    r: intervals[cur][<span class="hljs-number">1</span>],<br>                &#125;);<br>                tree.<span class="hljs-title function_ invoke__">insert</span>(TreeNode &#123;<br>                    i: cur,<br>                    l: intervals[cur][<span class="hljs-number">0</span>],<br>                    r: intervals[cur][<span class="hljs-number">1</span>],<br>                &#125;);<br>                cur += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> !h.<span class="hljs-title function_ invoke__">is_empty</span>() &amp;&amp; h.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">unwrap</span>().r &lt; q &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = h.<span class="hljs-title function_ invoke__">pop</span>().<span class="hljs-title function_ invoke__">unwrap</span>().i;<br>                tree.<span class="hljs-title function_ invoke__">remove</span>(&amp;TreeNode &#123;<br>                    i: c,<br>                    l: intervals[c][<span class="hljs-number">0</span>],<br>                    r: intervals[c][<span class="hljs-number">1</span>],<br>                &#125;);<br>            &#125;<br>            <span class="hljs-keyword">if</span> !tree.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = tree.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>().i;<br>                ans[id] = intervals[c][<span class="hljs-number">1</span>] - intervals[c][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        ans<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>平衡树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Golang 使用红黑树</title>
    <link href="/2023/07/18/Leetcode-Golang-%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2023/07/18/Leetcode-Golang-%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>Golang 是没有红黑树的, 但是 Golang 有 Gods</p>          </div><p>Golang 的 <a href="https://github.com/emirpasic/gods#redblacktree">Gods</a> 是一个开源库, 里面实现了基本上常用的数据结构, 自然包括红黑树. 最常用的也是它了, 其他的数据结构使用标准库就可以.</p><h2 id="给个例子"><a href="#给个例子" class="headerlink" title="给个例子"></a>给个例子</h2><p>这个例子是项目<code>Demo</code>里的. 除了 <code>NewWithIntComparator</code> 还可以使用 <code>NewWithStringComparator</code>.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>rbt <span class="hljs-string">&quot;github.com/emirpasic/gods/trees/redblacktree&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tree := rbt.NewWithIntComparator() <span class="hljs-comment">// empty (keys are of type int)</span><br><br>tree.Put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;x&quot;</span>) <span class="hljs-comment">// 1-&gt;x</span><br>tree.Put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>) <span class="hljs-comment">// 1-&gt;x, 2-&gt;b (in order)</span><br>tree.Put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-comment">// 1-&gt;a, 2-&gt;b (in order, replacement)</span><br>tree.Put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>) <span class="hljs-comment">// 1-&gt;a, 2-&gt;b, 3-&gt;c (in order)</span><br>tree.Put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;d&quot;</span>) <span class="hljs-comment">// 1-&gt;a, 2-&gt;b, 3-&gt;c, 4-&gt;d (in order)</span><br>tree.Put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;e&quot;</span>) <span class="hljs-comment">// 1-&gt;a, 2-&gt;b, 3-&gt;c, 4-&gt;d, 5-&gt;e (in order)</span><br>tree.Put(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;f&quot;</span>) <span class="hljs-comment">// 1-&gt;a, 2-&gt;b, 3-&gt;c, 4-&gt;d, 5-&gt;e, 6-&gt;f (in order)</span><br><br>fmt.Println(tree)<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  RedBlackTree</span><br><span class="hljs-comment">//  │           ┌── 6</span><br><span class="hljs-comment">//│       ┌── 5</span><br><span class="hljs-comment">//│   ┌── 4</span><br><span class="hljs-comment">//│   │   └── 3</span><br><span class="hljs-comment">//└── 2</span><br><span class="hljs-comment">//└── 1</span><br><br>_ = tree.Values() <span class="hljs-comment">// []interface &#123;&#125;&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125; (in order)</span><br>_ = tree.Keys()   <span class="hljs-comment">// []interface &#123;&#125;&#123;1, 2, 3, 4, 5, 6&#125; (in order)</span><br><br>tree.Remove(<span class="hljs-number">2</span>) <span class="hljs-comment">// 1-&gt;a, 3-&gt;c, 4-&gt;d, 5-&gt;e, 6-&gt;f (in order)</span><br>fmt.Println(tree)<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  RedBlackTree</span><br><span class="hljs-comment">//  │       ┌── 6</span><br><span class="hljs-comment">//  │   ┌── 5</span><br><span class="hljs-comment">//  └── 4</span><br><span class="hljs-comment">//      │   ┌── 3</span><br><span class="hljs-comment">//      └── 1</span><br><br>tree.Clear() <span class="hljs-comment">// empty</span><br>tree.Empty() <span class="hljs-comment">// true</span><br>tree.Size()  <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// Other:</span><br>tree.Left() <span class="hljs-comment">// gets the left-most (min) node</span><br>tree.Right() <span class="hljs-comment">// get the right-most (max) node</span><br>tree.Floor(<span class="hljs-number">1</span>) <span class="hljs-comment">// get the floor node</span><br>tree.Ceiling(<span class="hljs-number">1</span>) <span class="hljs-comment">// get the ceiling node</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是这还不是最重要的, 因为很多时候都是需要使用自己定义的结构体来当做键. 这如何处理呢?</p><h2 id="NewWith-自己定义比较函数"><a href="#NewWith-自己定义比较函数" class="headerlink" title="NewWith 自己定义比较函数"></a><code>NewWith</code> 自己定义比较函数</h2><p>这是 <code>NewWith</code> 的函数签名, 需要给一个 <code>Comparator</code> 比较函数, 非常直观, 在短时间内就可以写出一个可用的平衡树, 不想 <code>C++</code> 或 <code>Rust</code> 那样, 要写一些比较结构.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// NewWith instantiates a red-black tree with the custom comparator.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewWith</span><span class="hljs-params">(comparator utils.Comparator)</span></span> *Tree &#123;<br><span class="hljs-keyword">return</span> &amp;Tree&#123;Comparator: comparator&#125;<br>&#125;<br><br><span class="hljs-comment">// Should return a number:</span><br><span class="hljs-comment">//    negative , if a &lt; b</span><br><span class="hljs-comment">//    zero     , if a == b</span><br><span class="hljs-comment">//    positive , if a &gt; b</span><br><span class="hljs-keyword">type</span> Comparator <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><blockquote><p>现在有一个 <code>intervals [][]int</code> 二维数组, 表示一堆间隔 <code>len(intervals[0]) = 2</code>. 现在想要制造一个红黑树, 把间隔短的放在最前面. 如果间隔相等, 无所谓顺序. 即如果 <code>intervals[i][1]-intervals[i][0]</code> 小于 <code>intervals[j][1]-intervals[j][0]</code>, 那么 <code>i</code> 应该在 <code>j</code> 前面. 因为可能会很多删除和添加, 不能简单使用排序, 而是要用平衡树.</p></blockquote><div class="note note-success">            <p>Solution: 我们可以使用 <code>NewWith</code> 方法加一个自己定义的比较函数完成. 需要注意, 尽管顺序相等无所谓顺序, 但是, 在编写比较函数时, 要固定下来, 如果不固定的话, 插入和查询可能行为不一致.</p>          </div><p>我们可以仅仅把<code>intervals</code>的索引当做键, 因为<code>Golang</code>有闭包, 不用闭包的话, 还应该传入一个用于比较的<code>cost</code>.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Golang">comp := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a == b &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>&#125;<br><br>tree := redblacktree.NewWith(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">int</span> &#123;<br>    ia, ib := a.(<span class="hljs-type">int</span>), b.(<span class="hljs-type">int</span>)<br>    ra, rb := intervals[ia][<span class="hljs-number">1</span>]-intervals[ia][<span class="hljs-number">0</span>], intervals[ib][<span class="hljs-number">1</span>]-intervals[ib][<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 如果间隔不相等, 就按照间隔的比较</span><br>    <span class="hljs-keyword">if</span> x := comp(ra, rb); x != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果间隔相等, 那就按照 索引 的大小比较</span><br>        <span class="hljs-keyword">return</span> comp(ia, ib)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>需要注意, 这里判断键相等的条件就是传入 <code>NewWith</code> 的闭包返回 <code>0</code>, 只要传入两个键, 闭包返回<code>0</code>了, 就认为两个键是相同的, 只能存在一个! 这里必不可能返回 <code>0</code>, 可以思考一下为什么. 因此, 可以加一个扩展域, 实现一个简陋的 <code>MultiSet/MultiMap</code>. 但是一般在<code>Leetcdoe</code>上也是很少用的. </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu因为磁盘满占用问题启动不了图形界面问题及解决方案</title>
    <link href="/2023/05/03/Ubuntu%E5%9B%A0%E4%B8%BA%E7%A3%81%E7%9B%98%E6%BB%A1%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%E5%90%AF%E5%8A%A8%E4%B8%8D%E4%BA%86%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/05/03/Ubuntu%E5%9B%A0%E4%B8%BA%E7%A3%81%E7%9B%98%E6%BB%A1%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%E5%90%AF%E5%8A%A8%E4%B8%8D%E4%BA%86%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>如果你有一个线程&#x2F;进程一直在写 log 或者其他中间文件，而且恰巧你不喜欢定时重启清理一下资源，那么很有可能会因为根目录磁盘空间被占满而导致下次启动时启动不了图形界面，因为没有空间启动了！</p>          </div><p>作为一个桌面系统，我对磁盘的划分比较简单就是一个 128g 固态作为了 <code>/</code> 根目录，剩下的 1T 机械经盘 作为 <code>/home</code> 家目录。<br>之前遇到过这样一个问题，有一个系统进程一直在写 <code>system log</code>，而且杀不死，这样就把 <code>/var</code> 目录占满了 根目录 的所有磁盘空间，这样重启后导致了磁盘空间不足以启动图形界面的问题，今天又遇到了，特意在此记录一下。</p><h2 id="查找哪个文件导致的磁盘占满"><a href="#查找哪个文件导致的磁盘占满" class="headerlink" title="查找哪个文件导致的磁盘占满"></a>查找哪个文件导致的磁盘占满</h2><div class="note note-warning">            <p>如果进不去图形界面，需要进入 <code>tty</code> 模式。</p>          </div><p>使用 <code>df</code> 命令先定位到哪个分区占用最大，大概率是 <code>/</code>根目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230503141826.png" alt="查看分区大小"></p><h2 id="定位大文件"><a href="#定位大文件" class="headerlink" title="定位大文件"></a>定位大文件</h2><p>使用 <code>du</code> 命令定位到具体的文件大小，这个需要一层一层查找了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找根目录大文件</span><br><span class="hljs-built_in">cd</span> /<br><span class="hljs-built_in">du</span> -sh ./*<br><span class="hljs-comment"># 也可以查找时排序一下</span><br><span class="hljs-built_in">du</span> -sh ./* | <span class="hljs-built_in">sort</span> -h -r<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230503142344.png" alt="查找不正常目录"></p><blockquote><p>这里定位到是 <code>tmp</code> 文件夹，大概率重启是没有问题的，因为 linux 重启会清空这个目录。这是我在没有重启前就察觉到了那个异常进程，第一次遇到时，是在 <code>/var</code> 目录下，这个重启就没有办法了。 </p></blockquote><p><code>du</code> 参数说明</p><ul><li>-a或-all 显示目录中个别文件的大小。</li><li>-b或-bytes 显示目录或文件大小时，以byte为单位。</li><li>-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</li><li>-D或–dereference-args 显示指定符号连接的源文件大小。</li><li>-h或–human-readable 以K，M，G为单位，提高信息的可读性。</li><li>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。</li><li>-k或–kilobytes 以1024 bytes为单位。</li><li>-l或–count-links 重复计算硬件连接的文件。</li><li>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。</li><li>-m或–megabytes 以1MB为单位。</li><li>-s或–summarize 仅显示总计。</li><li>-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</li><li>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</li><li>-X&lt;文件&gt;或–exclude-from&#x3D;&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。</li><li>–exclude&#x3D;&lt;目录或文件&gt; 略过指定的目录或文件。</li><li>–max-depth&#x3D;&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。</li><li>–help 显示帮助。</li><li>–version 显示版本信息。</li></ul><p><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230503142644.png" alt="找到异常大文件"></p><p>把它删除就好了！</p><div class="note note-secondary">            <p>原来是 知网 阅览器写日志异常！！！</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux命令</tag>
      
      <tag>Linux问题及解决方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 如何像 Golang 一样使用二分</title>
    <link href="/2023/04/28/Rust-%E5%A6%82%E4%BD%95%E5%83%8F-Golang-%E4%B8%80%E6%A0%B7%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%88%86/"/>
    <url>/2023/04/28/Rust-%E5%A6%82%E4%BD%95%E5%83%8F-Golang-%E4%B8%80%E6%A0%B7%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>二分是一个简单的算法，但是里面的细节还是有很多的，这篇文章会讲解 Rust 和 Golang 标准库为程序员快速写出二分代码做了哪些努力。并介绍 Rust 标准库对二分的限制，以及如何给 Rust 写一个像 Golang 一样的更通用的二分框架。</p>          </div><blockquote><p>这篇文章假设读者已经完全掌握了二分的朴素写法，包括定义二段性，证明二段性，以及二分的左右边界等等。</p></blockquote><h1 id="Golang-里的二分"><a href="#Golang-里的二分" class="headerlink" title="Golang 里的二分"></a>Golang 里的二分</h1><p>Golang 标准库里有 <code>sort</code> 包，它不止用来排序，还封装了<code>二分</code>的代码。你可以使用<code>sort.Search</code> 或者 <code>sort.SearchInts</code>，<code>sort.SearchStrings</code> 等等。</p><h2 id="sort-Search"><a href="#sort-Search" class="headerlink" title="sort.Search"></a>sort.Search</h2><p>这是更加通用的 API，标准库实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span><span class="hljs-params">(n <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// Define f(-1) == false and f(n) == true.</span><br><span class="hljs-comment">// Invariant: f(i-1) == false, f(j) == true.</span><br>i, j := <span class="hljs-number">0</span>, n<br><span class="hljs-keyword">for</span> i &lt; j &#123;<br>h := <span class="hljs-type">int</span>(<span class="hljs-type">uint</span>(i+j) &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// avoid overflow when computing h</span><br><span class="hljs-comment">// i ≤ h &lt; j</span><br><span class="hljs-keyword">if</span> !f(h) &#123;<br>i = h + <span class="hljs-number">1</span> <span class="hljs-comment">// preserves f(i-1) == false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>j = h <span class="hljs-comment">// preserves f(j) == true</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</span><br><span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><p>实现非常简单，其实就是把朴素二分分装了一下，它有几个特点：</p><ol><li>需要定义一个 check 函数 <code>f</code>。</li><li><code>f</code> 是左偏的，意思是，如果有多个返回 true 的值，会返回最左边的那个，这看上去像是从左往右找到第一个 <code>f</code> 返回 true 的值。</li><li>最好是写成 <code>条件 &gt;= (&gt;) 固定值</code> 的形式，并且 <code>&gt;=</code> 是做边界， <code>&gt;</code>  是有边界的下标 <code>+1</code>。这个条件可以不用证明。只需要记住 <span class="label label-primary">从左往右找到第一个 `f` 返回 true 的值</span>。</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">index</span> | <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span> | <span class="hljs-number">6</span><br><span class="hljs-attribute">value</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">5</span> | <span class="hljs-number">5</span> | <span class="hljs-number">5</span> | <span class="hljs-number">7</span> | <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;<br>left := sort.Search(<span class="hljs-built_in">len</span>(a), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> a[i] &gt;= <span class="hljs-number">5</span> &#125;) <span class="hljs-comment">// 左边界</span><br>right := sort.Search(<span class="hljs-built_in">len</span>(a), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> a[i] &gt; <span class="hljs-number">5</span> &#125;) <span class="hljs-comment">// 有边界+1</span><br>fmt.Println(left, right) <span class="hljs-comment">// 打印： 2, 5</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这是一个最简单的例子，其他的也类似，因此在比赛时，可以快速写出二分，只需要写 check 函数即可。</p></blockquote><h2 id="sort-SearchInts"><a href="#sort-SearchInts" class="headerlink" title="sort.SearchInts"></a>sort.SearchInts</h2><p>这其实是为 <code>slice</code> 封装的一个 API:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SearchInts</span><span class="hljs-params">(a []<span class="hljs-type">int</span>, x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> Search(<span class="hljs-built_in">len</span>(a), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> a[i] &gt;= x &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以发现，这就是使用 <code>sort.Search</code> 封装的而已。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;<br>l := sort.SearchInts(a, <span class="hljs-number">5</span>)<br>r := sort.SearchInts(a, <span class="hljs-number">5</span>+<span class="hljs-number">1</span>)<br>fmt.Println(l, r) <span class="hljs-comment">// 打印： 2, 5</span><br></code></pre></td></tr></table></figure><h1 id="Rust-里的二分"><a href="#Rust-里的二分" class="headerlink" title="Rust 里的二分"></a>Rust 里的二分</h1><p>Rust 和 Golang 还是有些区别的，因为，Rust 泛型和模块化更加精细，Rust 不会像 Golang 一样为了排序还需要重新定义一个包，Rust 直接把排序方法放在 <code>slice</code> 里就好了。</p><div class="note note-primary">            <p>Rust 中有一些二分函数，但是最常用的是<a href="https://doc.rust-lang.org/std/primitive.slice.html#method.partition_point"><code>partition_point</code></a>。</p>          </div><p>这里就不展示源码了，其实实现方式差不多，但是需要注意 Rust 的逻辑是反着的，也就是从左往右找，找到第一个不符合条件的。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">index</span> | <span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span> | <span class="hljs-number">5</span> | <span class="hljs-number">6</span><br><span class="hljs-attribute">value</span> | <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">5</span> | <span class="hljs-number">5</span> | <span class="hljs-number">5</span> | <span class="hljs-number">7</span> | <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = &amp;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">left</span> = a.<span class="hljs-title function_ invoke__">partition_point</span>(|&amp;t| t &lt; <span class="hljs-number">5</span>); <span class="hljs-comment">// 左边界</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">right</span> = a.<span class="hljs-title function_ invoke__">partition_point</span>(|&amp;t| t &lt;= <span class="hljs-number">5</span>); <span class="hljs-comment">// 右边界</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, left, right); <span class="hljs-comment">// 打印： 2，5</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>Rust 二分方法只用用在 array 和 slice 上，就不能像 Golang。什么意思呢？就是说 Golang 可以 <code>sort.Search(int(1e9), ....)</code>，但是 Rust 需要先声明一个 vector [0..1e9] 才能使用<code>partition_point</code>，这显然是不现实的。</p>          </div><h2 id="如何让-Rust-表现得像-Golang-一样"><a href="#如何让-Rust-表现得像-Golang-一样" class="headerlink" title="如何让 Rust 表现得像 Golang 一样"></a>如何让 Rust 表现得像 Golang 一样</h2><p>也就是给 Rust 写一个函数就好，像 Golang 一样，但是由于 Rust 对闭包的限制，需要使用 Rust 中的动态分发（dynamic dispatch），关于这一点以后可以写一篇文章详细介绍。因为 <span class="label label-primary">Rust 闭包不支持范性</span>，所以只能在运行时采用 dynamic dispatch 包装一下，Rust 有两种 dynamic dispatch：</p><ol><li><code>&amp;dyn Trait</code></li><li><code>Box&lt;dyn Trait&gt;</code></li></ol><div class="note note-info">            <p>Tip: Rust dynamic dispatch 是一个 fat pointer，是包含类型大小的，所以才可以编译通过</p>          </div><h3 id="1-dyn-Trait"><a href="#1-dyn-Trait" class="headerlink" title="1.&amp;dyn Trait"></a>1.<code>&amp;dyn Trait</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">search</span> = |n: <span class="hljs-type">usize</span>, f: &amp;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>| &#123;<br>        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> l, <span class="hljs-keyword">mut</span> r) = (<span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">while</span> l &lt; r &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> !<span class="hljs-title function_ invoke__">f</span>(mid) &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;;<br></code></pre></td></tr></table></figure><h3 id="2-Box"><a href="#2-Box" class="headerlink" title="2.Box&lt;dyn Trait&gt;"></a>2.<code>Box&lt;dyn Trait&gt;</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">search</span> = |n: <span class="hljs-type">usize</span>, f: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>&gt;| &#123;<br>    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> l, <span class="hljs-keyword">mut</span> r) = (<span class="hljs-number">0</span>, n);<br>    <span class="hljs-keyword">while</span> l &lt; r &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> !<span class="hljs-title function_ invoke__">f</span>(mid) &#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = &amp;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">search</span> = |n: <span class="hljs-type">usize</span>, f: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>&gt;| &#123;<br>        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> l, <span class="hljs-keyword">mut</span> r) = (<span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">while</span> l &lt; r &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> !<span class="hljs-title function_ invoke__">f</span>(mid) &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">left</span> = <span class="hljs-title function_ invoke__">search</span>(a.<span class="hljs-title function_ invoke__">len</span>(), <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(|t| a[t] &gt;= <span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">right</span> = <span class="hljs-title function_ invoke__">search</span>(a.<span class="hljs-title function_ invoke__">len</span>(), <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(|t| a[t] &gt; <span class="hljs-number">5</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, left, right); <span class="hljs-comment">// 打印 2, 5</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Rust for ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>直接IO (Direct IO) 及 Golang 实现</title>
    <link href="/2023/04/20/%E7%9B%B4%E6%8E%A5IO-Direct-IO-%E5%8F%8A-Golang-%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/04/20/%E7%9B%B4%E6%8E%A5IO-Direct-IO-%E5%8F%8A-Golang-%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>Linux 读磁盘一般是会有缓存的，可是有缓存一定会好吗？</p>          </div><h1 id="什么是-直接IO？"><a href="#什么是-直接IO？" class="headerlink" title="什么是 直接IO？"></a>什么是 直接IO？</h1><h2 id="直接IO-概念和-直接IO-使用场景"><a href="#直接IO-概念和-直接IO-使用场景" class="headerlink" title="直接IO 概念和 直接IO 使用场景"></a>直接IO 概念和 直接IO 使用场景</h2><p>我们假设这样一个场景，如果应用程序需要读取一个文件，这里需要读取后在应用层进行一些操作，请假设应用程序使用传统的 read 方式（忘记 mmap 和 零拷贝）。那么读取一个文件过程是这样的：</p><!-- ![](https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230420194730.png) --><p><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230420194903.png" alt="内存拷贝"></p><ol><li>执行 read 操作</li><li>执行系统调用，从用户态改为内核态，假设文件没有在内核缓冲区中命中</li><li>内核使用 DMA（direct memory access）从磁盘读取文件到内核缓冲区 page cache 中</li><li>CPU 将 page cache 中的文件读取到用户缓冲区</li></ol><p>以上是一般读取文件 IO 的操作，但是这有什么问题呢？</p><ol><li>读取小文件时，或者热点文件时，预读与缓存技术是没有问题的，但是一旦文件是 GB 级别，那么读取文件会有两个问题：<ul><li>预读直接打满 page cache，使得小文件热点文件直接失效；</li><li>大文件几乎永不倒缓存功能，浪费 page cache 空间</li></ul></li><li>有些程序自己定义了缓存，更倾向于使用自己的缓存，而不是操作系统的 page cache，比如 MySQL。</li></ol><div class="note note-secondary">            <p>所以，在读取大文件时，往往需要绕过 page cache，在内核态直接将文件内容加载到 用户缓冲区。这就是 直接IO，可以叫做 DIO（direct IO）。</p>          </div><p>但是，直接IO 有一个很大的问题，就是在读取大文件时往往会阻塞很长时间，所以一般需要通过 异步读取 的方式进行 直接IO，过程如下（图片来源于<a href="https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0">小林coding</a>）：</p><p><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230420195952.png" alt="直接IO"></p><!-- 图片来自 [小林coding](https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0) --><h2 id="直接IO-限制"><a href="#直接IO-限制" class="headerlink" title="直接IO 限制"></a>直接IO 限制</h2><p>因为是直接从磁盘读入用户缓冲区，但是磁盘是划分扇区的，那怎么保证用户使用的缓冲区和磁盘对应起来呢？这就需要：</p><ol><li>一次 IO 读写操作需要和扇区对齐</li><li>用户缓冲区地址必须和磁盘扇区对齐</li></ol><blockquote><p>磁盘的扇区一般多大呢？如果磁盘比较小，一般是 512B，但是现在也有很多是一个内存页的大小（即 4K），可以使用 <code>fdisk -l 查看</code>。我们定义 <strong><code>AlignSize</code></strong> 为系统的扇区对齐大小。</p></blockquote><p>第一点是比较容易满足的，可以很容易控制一次读取或者写入的大小，但是第二点就需要一些技巧了，接下来就介绍一下如何使用 Golang 在 Linux 下实现 直接IO。</p><h1 id="Golang-实现-直接IO"><a href="#Golang-实现-直接IO" class="headerlink" title="Golang 实现 直接IO"></a>Golang 实现 直接IO</h1><h2 id="如何以-直接IO-的形式打开文件"><a href="#如何以-直接IO-的形式打开文件" class="headerlink" title="如何以 直接IO 的形式打开文件"></a>如何以 直接IO 的形式打开文件</h2><p>Linux 下使用直接IO 需要使用参数 <code>O_DIRECT</code>，但是由于其是夸平台的，所以这个参数是放在了 <code>syscall</code> 包下。<br>可以使用一下命令打开文件：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang">file := os.OpenFile(name, syscall.O_DIRECT|flag, perm)<br></code></pre></td></tr></table></figure><h2 id="如何定义-Buffer-对齐"><a href="#如何定义-Buffer-对齐" class="headerlink" title="如何定义 Buffer 对齐"></a>如何定义 Buffer 对齐</h2><p>申请内存的时候是按照 8B 大小对齐的（64位），那怎么对应到 512B 呢（假设 AlignSize &#x3D; 512B）？答案是没有办法直接对应，只能申请多余的内存，然后自己偏移。<br><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230420204624.png" alt="申请内存时进行偏移对齐"></p><div class="note note-warning">            <p>假设在用户程序申请一块大小 4096B 大小的缓冲区，假设得到的地址是 P，那就需要在地址为 <code>[P, P+256]</code> 这个区间内找到对齐的一个地址作为新的开始地址返回给用户使用</p>          </div><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">const</span> (<br>AlignSize = <span class="hljs-number">512</span><br>)<br><br><span class="hljs-comment">// 查找偏移地址，其实就是 P % AlignSize 的 2进制 优化，因为 AlignSize 必定是 2^k</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">alignment</span><span class="hljs-params">(block []<span class="hljs-type">byte</span>, AlignSize <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(<span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;block[<span class="hljs-number">0</span>])) &amp; <span class="hljs-type">uintptr</span>(AlignSize<span class="hljs-number">-1</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsAligned</span><span class="hljs-params">(block []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> alignment(block, AlignSize) == <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 参数 BlockSize 一定是 AlignSize 的倍数，满足 条件1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AlignedBlock</span><span class="hljs-params">(BlockSize <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>block := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, BlockSize+AlignSize)<br><span class="hljs-keyword">if</span> AlignSize == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> block<br>&#125;<br>    <span class="hljs-comment">// 获取偏移地址</span><br>a := alignment(block, AlignSize)<br>offset := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> a != <span class="hljs-number">0</span> &#123;<br>offset = AlignSize - a<br>&#125;<br><br>block = block[offset : offset+BlockSize]<br><span class="hljs-keyword">if</span> BlockSize != <span class="hljs-number">0</span> &amp;&amp; !IsAligned(block) &#123;<br>        log.Fatal(<span class="hljs-string">&quot;Failed to align block&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> block<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这其实就是 开源库 <a href="https://github.com/ncw/directio">directio</a> 的实现。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Neovim 插件|文件系统--Neo-tree.nvim</title>
    <link href="/2023/04/18/Neovim-%E6%8F%92%E4%BB%B6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-Neo-tree-nvim/"/>
    <url>/2023/04/18/Neovim-%E6%8F%92%E4%BB%B6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-Neo-tree-nvim/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>这可能是每个 IDE 或者 编辑器 都必须做到的基本功能 – 文件管理</p>          </div><p>文件管理一般是 IDE 的 sidebar，你以前可能对 vscode 这种集成的 文件管理 sidebar 没有过多配置，因为这是最基本的，直接开盒即用的。但是其功能往往比大多数开发者现在使用到的要多一些。<br>那么，接下来，我们以开发者的角度去在 Neovim 下配置一个专属的 文件管理器。</p><p>首先，一个合格的 文件管理器 需要具备什么功能的？</p><ol><li><strong>文件浏览</strong>（废话，不然为什么叫 文件管理器🤣，这也是 90% 的需求了）</li><li><strong>文件操作</strong>（比如，文件改名，文件移动，文件复制等等）</li><li><strong>反向定位</strong>（从窗口中，定位到 文件管理器 中该文件的目录）</li><li><strong>可以按需求过滤文件</strong>（比如在 .gitignore 里的文件，隐藏文件等等，这些文件我们大概率不需要看到）</li><li><strong>可以在</strong> 文件管理器 里，多方位打开文件（并不仅仅覆盖当前窗口，还要有比如平行打开，垂直打开等等）</li><li><strong>多信息</strong>（比如显示 git 相关信息，LSP server 检查信息等等）</li></ol><hr><p>很可能自己都没有注意，一个 文件管理器 可以集成很多功能，而不仅仅是进行文件的查看。而且这些功能在自己开发过程中，往往可以节省自己不少时间。</p><hr><p>接下来就介绍今天的主角吧 – Neo-tree <a href="https://github.com/nvim-neo-tree/neo-tree.nvim">github 地址</a>。</p><p><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230418195259.png" alt="neo-tree"><br><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230418195437.png" alt="neo-tree-float"></p><div class="note note-secondary">            <p>Neo-tree 是 Nvim-tree 的后继者，Neo-tree 具有两大特点：</p><ol><li>稳定，大版本内不会有 breaking changes</li><li>高定制化</li></ol>          </div><h2 id="Neo-tree-使用-lazy-最小化安装"><a href="#Neo-tree-使用-lazy-最小化安装" class="headerlink" title="Neo-tree 使用 lazy 最小化安装"></a>Neo-tree 使用 lazy 最小化安装</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> M = &#123;<br>  <span class="hljs-string">&quot;nvim-neo-tree/neo-tree.nvim&quot;</span>,<br>  dependencies = &#123;<br>    <span class="hljs-string">&quot;nvim-lua/plenary.nvim&quot;</span>,<br>    <span class="hljs-string">&quot;nvim-tree/nvim-web-devicons&quot;</span>, <span class="hljs-comment">-- not strictly required, but recommended</span><br>    <span class="hljs-string">&quot;MunifTanjim/nui.nvim&quot;</span>,<br>  &#125;,<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.config</span><span class="hljs-params">()</span></span><br>  vim.g.neo_tree_remove_legacy_commands = <span class="hljs-number">1</span><br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;neo-tree&quot;</span>).setup()<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><h2 id="Neo-tree-命令组成"><a href="#Neo-tree-命令组成" class="headerlink" title="Neo-tree 命令组成"></a>Neo-tree 命令组成</h2><p>Neo-tree 命令有两大模式： Neotree 模式和 NeoTree* 模式。（这里很像，但是注意第一个 tree，第二个是 Tree，一个小写，一个大写）</p><div class="note note-danger">            <p>请不要在使用 NeoTree* 命令，因为它们已经被弃用了！在 v3.0 版本下将会彻底删除，如果你使用 <code>vim.g.neo_tree_remove_legacy_commands = 1</code>，那么 NeoTree* 模式命令是不可见的！建议打开。  </p>          </div><h3 id="NeoTree-模式（将来会被弃用）"><a href="#NeoTree-模式（将来会被弃用）" class="headerlink" title="NeoTree* 模式（将来会被弃用）"></a>NeoTree* 模式（将来会被弃用）</h3><p>NeoTree* 模式就是 Neo-tree 把一些常用的命令定义成了一个以 NeoTree 开头的命令，可以直接使用，如下图：<br><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230418200036.png" alt="NeoTree*"><br>所以，这里主要介绍 Neotree 模式，因为它更通用一些。</p><h3 id="Neotree-命令模式"><a href="#Neotree-命令模式" class="headerlink" title="Neotree 命令模式"></a>Neotree 命令模式</h3><p>Neotree 命令即使用 Neotree 命令加上一些参数来使用 Neo-tree 提供的所有功能。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">:Neotree action=show source=buffers position=right toggle=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>action</strong><br>做什么</p><pre><code class="hljs">focus : Show and/or switch focus to the specified Neotree window. DEFAULTshow  : Show the window, but keep focus on your current window.close : Close the window(s) specified. Can be combined with &quot;position&quot;         and/or &quot;source&quot; to specify which window(s) to close.</code></pre><p><strong>source</strong><br>要显示什么，可以现实 文件系统，打开的 buffers 或者 git_status</p><pre><code class="hljs">filesystem : Show a file browser. DEFAULTbuffers    : Show a list of currently open buffers.git_status : Show the output of `git status` in a tree layout.</code></pre><p><strong>position</strong><br>打开的位置</p><pre><code class="hljs">left    : Open as left hand sidebar. DEFAULTright   : Open as right hand sidebar.float   : Open as floating window.current : Open within the current window, like netrw or vinegar would.</code></pre><p><strong>toggle</strong></p><blockquote><p>This is a boolean flag. Adding this means that the window will be closed if it is already open.</p></blockquote><p><strong>reveal</strong></p><blockquote><p>This is a boolean flag. Adding this will make Neotree automatically find and focus the current file when it opens.</p></blockquote><p><strong>reveal_path</strong></p><blockquote><p>A path to a file to reveal. This supersedes the “reveal” flag so there is no need to specify both. Use this if you want to reveal something other than the current file. If you include a path to a file as one of the arguments, it will be assumed to be this option. Like “dir”, you can pass any value that can be passed to the ‘expand’ function.</p></blockquote><p><strong>reveal_force_cwd</strong></p><blockquote><p>This is a boolean flag. Normally, if you use one of the reveal options and the<br>given file is not within the current working directory, you will be asked if you<br>want to change the current working directory. If you include this flag, it will<br>automatically change the directory without prompting. This option implies<br>“reveal”, so you do not need to specify both.</p></blockquote><div class="note note-success">            <p>之所以建议使用 Neotree 命令, 是因为这个命令太好用了。它可以无视掉前面的类型，而且没有顺序！</p>          </div><p>也就是说，你可以使用：</p><ol><li><code>:Neotree toggle focus right</code> </li><li><code>:Neotree flaot buffers</code></li><li><code>:Neotree flaot reveal</code><br>总可以组合出你想要的结果：</li></ol><h2 id="Neo-tree-其他功能"><a href="#Neo-tree-其他功能" class="headerlink" title="Neo-tree 其他功能"></a>Neo-tree 其他功能</h2><p>Neo-tree 功能太多了，其他功能可以照着文档配置出你想要的结果。<br>这里给出我的配置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> M = &#123;<br>  <span class="hljs-string">&quot;nvim-neo-tree/neo-tree.nvim&quot;</span>,<br>  dependencies = &#123;<br>    <span class="hljs-string">&quot;nvim-lua/plenary.nvim&quot;</span>,<br>    <span class="hljs-string">&quot;nvim-tree/nvim-web-devicons&quot;</span>, <span class="hljs-comment">-- not strictly required, but recommended</span><br>    <span class="hljs-string">&quot;MunifTanjim/nui.nvim&quot;</span>,<br>  &#125;,<br>  init = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    vim.g.neo_tree_remove_legacy_commands = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">end</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.config</span><span class="hljs-params">()</span></span><br>  vim.keymap.set(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;&lt;c-f&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;cmd&gt;Neotree focus toggle &lt;cr&gt;&quot;</span>, &#123; desc = <span class="hljs-string">&quot;neo-tree focus toggle&quot;</span> &#125;)<br>  vim.keymap.set(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;&lt;c-d&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;cmd&gt;Neotree float toggle reveal&lt;cr&gt;&quot;</span>, &#123; desc = <span class="hljs-string">&quot;neo-tree float toggle&quot;</span> &#125;)<br><br>  vim.fn.sign_define(<span class="hljs-string">&quot;DiagnosticSignError&quot;</span>, &#123; text = <span class="hljs-string">&quot; &quot;</span>, texthl = <span class="hljs-string">&quot;DiagnosticSignError&quot;</span> &#125;)<br>  vim.fn.sign_define(<span class="hljs-string">&quot;DiagnosticSignWarn&quot;</span>, &#123; text = <span class="hljs-string">&quot; &quot;</span>, texthl = <span class="hljs-string">&quot;DiagnosticSignWarn&quot;</span> &#125;)<br>  vim.fn.sign_define(<span class="hljs-string">&quot;DiagnosticSignInfo&quot;</span>, &#123; text = <span class="hljs-string">&quot; &quot;</span>, texthl = <span class="hljs-string">&quot;DiagnosticSignInfo&quot;</span> &#125;)<br>  vim.fn.sign_define(<span class="hljs-string">&quot;DiagnosticSignHint&quot;</span>, &#123; text = <span class="hljs-string">&quot;&quot;</span>, texthl = <span class="hljs-string">&quot;DiagnosticSignHint&quot;</span> &#125;)<br><br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;neo-tree&quot;</span>).setup(&#123;<br>    popup_border_style = <span class="hljs-string">&quot;rounded&quot;</span>,<br>    window = &#123;<br>      <span class="hljs-comment">-- position = &quot;float&quot;,</span><br>      width = <span class="hljs-number">25</span>,<br>      mappings = &#123;<br>        [<span class="hljs-string">&quot;&lt;space&gt;&quot;</span>] = <span class="hljs-string">&quot;none&quot;</span>,<br>        [<span class="hljs-string">&quot;&lt;cr&gt;&quot;</span>] = <span class="hljs-string">&quot;focus_preview&quot;</span>,<br>        [<span class="hljs-string">&quot;l&quot;</span>] = <span class="hljs-string">&quot;open&quot;</span>,<br>        [<span class="hljs-string">&quot;s&quot;</span>] = <span class="hljs-string">&quot;open_split&quot;</span>,<br>        [<span class="hljs-string">&quot;v&quot;</span>] = <span class="hljs-string">&quot;open_vsplit&quot;</span>,<br>        [<span class="hljs-string">&quot;e&quot;</span>] = <span class="hljs-string">&quot;expand_all_nodes&quot;</span>,<br>      &#125;,<br>    &#125;,<br>    default_component_configs = &#123;<br>      indent = &#123;<br>        indent_marker = <span class="hljs-string">&quot;│&quot;</span>,<br>        last_indent_marker = <span class="hljs-string">&quot;╰&quot;</span>,<br>        with_expanders = <span class="hljs-literal">true</span>, <span class="hljs-comment">-- if nil and file nesting is enabled, will enable expanders</span><br>        expander_collapsed = <span class="hljs-string">&quot;&quot;</span>,<br>        expander_expanded = <span class="hljs-string">&quot;&quot;</span>,<br>        expander_highlight = <span class="hljs-string">&quot;NeoTreeExpander&quot;</span>,<br>      &#125;,<br>      icon = &#123;<br>        folder_closed = <span class="hljs-string">&quot;&quot;</span>,<br>        folder_open = <span class="hljs-string">&quot;&quot;</span>,<br>        folder_empty = <span class="hljs-string">&quot;&quot;</span>,<br>        default = <span class="hljs-string">&quot;&quot;</span>,<br>        highlight = <span class="hljs-string">&quot;NeoTreeFileIcon&quot;</span>,<br>      &#125;,<br>      git_status = &#123;<br>        symbols = &#123;<br>          <span class="hljs-comment">-- Change type</span><br>          added = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">-- or &quot;✚&quot;, but this is redundant info if you use git_status_colors on the name</span><br>          modified = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">-- or &quot;&quot;, but this is redundant info if you use git_status_colors on the name</span><br>          deleted = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">-- this can only be used in the git_status source</span><br>          renamed = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">-- this can only be used in the git_status source</span><br>          <span class="hljs-comment">-- Status type</span><br>          untracked = <span class="hljs-string">&quot;&quot;</span>,<br>          ignored = <span class="hljs-string">&quot;◌&quot;</span>,<br>          unstaged = <span class="hljs-string">&quot;✗&quot;</span>,<br>          staged = <span class="hljs-string">&quot;&quot;</span>,<br>          conflict = <span class="hljs-string">&quot;&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>    filesystem = &#123;<br>      <span class="hljs-comment">-- follow_current_file = true,</span><br>      window = &#123;<br>        mappings = &#123;<br>          [<span class="hljs-string">&quot;I&quot;</span>] = <span class="hljs-string">&quot;toggle_hidden&quot;</span>,<br>          [<span class="hljs-string">&quot;H&quot;</span>] = <span class="hljs-string">&quot;none&quot;</span>,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  &#125;)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Nvim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim 插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC.1125. 最小的必要团队</title>
    <link href="/2023/04/08/LC-1125-%E6%9C%80%E5%B0%8F%E7%9A%84%E5%BF%85%E8%A6%81%E5%9B%A2%E9%98%9F/"/>
    <url>/2023/04/08/LC-1125-%E6%9C%80%E5%B0%8F%E7%9A%84%E5%BF%85%E8%A6%81%E5%9B%A2%E9%98%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/problems/smallest-sufficient-team/description/">题目链接</a> | <a href="https://leetcode.cn/contest/weekly-contest-145">第 145 场单周赛</a> | <a href="https://leetcode.cn/contest/weekly-contest-145/problems/smallest-sufficient-team/">Q4</a> | 难度:2251</p>          </div><details><summary>题目描述</summary><p>作为项目经理，你规划了一份需求的技能清单 <code>req_skills</code>，并打算从备选人员名单 <code>people</code> 中选出些人组成一个「必要团队」（ 编号为 <code>i</code> 的备选人员 <code>people[i]</code> 含有一份该备选人员掌握的技能列表）。</p><p>所谓「必要团队」，就是在这个团队中，对于所需求的技能列表 <code>req_skills</code> 中列出的每项技能，团队中至少有一名成员已经掌握。可以用每个人的编号来表示团队中的成员：</p><ul>    <li>例如，团队 <code>team = [0, 1, 3]</code> 表示掌握技能分别为 <code>people[0]</code>，<code>people[1]</code>，和 <code>people[3]</code> 的备选人员。</li></ul><p>请你返回 <strong>任一</strong> 规模最小的必要团队，团队成员用人员编号表示。你可以按 <strong>任意顺序</strong> 返回答案，题目数据保证答案存在。</p><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]<strong>输出：</strong>[0,2]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]<strong>输出：</strong>[1,2]</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>1 <= req_skills.length <= 16</code></li>    <li><code>1 <= req_skills[i].length <= 16</code></li>    <li><code>req_skills[i]</code> 由小写英文字母组成</li>    <li><code>req_skills</code> 中的所有字符串 <strong>互不相同</strong></li>    <li><code>1 <= people.length <= 60</code></li>    <li><code>0 <= people[i].length <= 16</code></li>    <li><code>1 <= people[i][j].length <= 16</code></li>    <li><code>people[i][j]</code> 由小写英文字母组成</li>    <li><code>people[i]</code> 中的所有字符串 <strong>互不相同</strong></li>    <li><code>people[i]</code> 中的每个技能是 <code>req_skills</code> 中的技能</li>    <li>题目数据保证「必要团队」一定存在</li></ul></details><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>经典0&#x2F;1背包，如果只是求最小个数，会简单很多，这道题是求一个最优解。<br>题目分析如下：</p><ol><li>假设有 n 个技能，背包容量为 $1 &lt;&lt; n-1$; 就是枚举所有的容量</li><li>$dp(i)(j)$ 定义为 枚举前 i 个物品，容量为 j 时，最小的可能个数</li><li>$dfs(i,j)&#x3D;dfs(i−1,j∖people[i])+1\textit{dfs}(i, j) &#x3D;<br>\textit{dfs}(i-1, j\setminus\textit{people}[i])+1dfs(i,j)<br>&#x3D;dfs(i−1,j∖people[i])+1$</li></ol><div class="note note-primary">            <p>关键： 如何求最优解！</p>          </div><p>其实，只需要找到最优解的状态转移就好了, 最小个数 为 $dp(len(people), 1&lt;&lt;n-1)$</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go">cnt := f[<span class="hljs-built_in">len</span>(people)][all]<br>ans := []<span class="hljs-type">int</span>&#123;&#125;<br>last := <span class="hljs-built_in">len</span>(people)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(ans) &lt; cnt &#123;<br>    <span class="hljs-keyword">if</span> f[last][all] == f[last<span class="hljs-number">-1</span>][all&amp;^skill[last<span class="hljs-number">-1</span>]]+<span class="hljs-number">1</span> &#123;<br>        ans = <span class="hljs-built_in">append</span>(ans, last<span class="hljs-number">-1</span>)<br>        all = all &amp;^ skill[last<span class="hljs-number">-1</span>]<br>    &#125;<br>    last--<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这里给出两种解法，递推和记忆化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 递推</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">smallestSufficientTeam</span><span class="hljs-params">(req_skills []<span class="hljs-type">string</span>, people [][]<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(req_skills)<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(req_skills))<br><span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> req_skills &#123;<br>m[s] = <span class="hljs-number">1</span> &lt;&lt; i<br>&#125;<br><br>skill := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(people))<br><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> people &#123;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> p &#123;<br>c |= m[s]<br>&#125;<br>skill[i] = c<br>&#125;<br><br>all := <span class="hljs-number">1</span>&lt;&lt;n - <span class="hljs-number">1</span><br>f := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(people)+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> f &#123;<br>f[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>&lt;&lt;n)<br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> f[i] &#123;<br>f[i][j] = math.MaxInt32<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 以下为状态转移过程</span><br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> people &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= all; j++ &#123;<br>f[i+<span class="hljs-number">1</span>][j] = min(f[i][j], f[i][j&amp;^skill[i]]+<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br>cnt := f[<span class="hljs-built_in">len</span>(people)][all]<br>ans := []<span class="hljs-type">int</span>&#123;&#125;<br>last := <span class="hljs-built_in">len</span>(people)<br>    <span class="hljs-comment">// 题目说一定会有解，不用提判断，肯定可以转移够个数</span><br>    <span class="hljs-comment">// 不到个数，就进行转移判断</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(ans) &lt; cnt &#123;<br><span class="hljs-keyword">if</span> f[last][all] == f[last<span class="hljs-number">-1</span>][all&amp;^skill[last<span class="hljs-number">-1</span>]]+<span class="hljs-number">1</span> &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, last<span class="hljs-number">-1</span>)<br>all = all &amp;^ skill[last<span class="hljs-number">-1</span>]<br>&#125;<br>last--<br>&#125;<br><br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// 记忆化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">smallestSufficientTeam</span><span class="hljs-params">(req_skills []<span class="hljs-type">string</span>, people [][]<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(req_skills)<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(req_skills))<br><span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> req_skills &#123;<br>m[s] = <span class="hljs-number">1</span> &lt;&lt; i<br>&#125;<br><br>skill := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(people))<br><span class="hljs-keyword">for</span> i, p := <span class="hljs-keyword">range</span> people &#123;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> p &#123;<br>c |= m[s]<br>&#125;<br>skill[i] = c<br>&#125;<br><br>all := <span class="hljs-number">1</span>&lt;&lt;n - <span class="hljs-number">1</span><br>f := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(people)+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> f &#123;<br>f[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>&lt;&lt;n)<br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> f[i] &#123;<br>f[i][j] = <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, mask <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br>dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, mask <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(people) &#123;<br><span class="hljs-keyword">if</span> mask == all &#123;<br>f[i][mask] = <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>f[i][mask] = math.MaxInt32<br><span class="hljs-keyword">return</span> math.MaxInt32<br>&#125;<br><span class="hljs-keyword">if</span> f[i][mask] != <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> f[i][mask]<br>&#125;<br><br>r := dfs(i+<span class="hljs-number">1</span>, mask)<br>r = min(r, dfs(i+<span class="hljs-number">1</span>, mask|skill[i])+<span class="hljs-number">1</span>)<br>f[i][mask] = r<br><span class="hljs-keyword">return</span> r<br>&#125;<br>cnt := dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// fmt.Println(f)</span><br><br><span class="hljs-comment">// fmt.Println(cnt)</span><br>ans := []<span class="hljs-type">int</span>&#123;&#125;<br>st := <span class="hljs-number">0</span><br>cur := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(ans) &lt; cnt &#123;<br><span class="hljs-keyword">if</span> f[st][cur] == f[st+<span class="hljs-number">1</span>][cur] &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cur |= skill[st]<br>ans = <span class="hljs-built_in">append</span>(ans, st)<br>&#125;<br>st++<br>&#125;<br><br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>0/1背包</tag>
      
      <tag>动态规划</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-328周赛</title>
    <link href="/2023/01/15/LC-328%E5%91%A8%E8%B5%9B/"/>
    <url>/2023/01/15/LC-328%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/contest/weekly-contest-328/">第 328 场单周赛</a></p>          </div><details><summary>题目描述</summary><ol><li><a href="https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array/">数组元素和与数字和的绝对差</a> | 简单</li><li><a href="https://leetcode.cn/problems/increment-submatrices-by-one/">子矩阵元素加1</a> | 中等</li><li><a href="https://leetcode.cn/problems/count-the-number-of-good-subarrays">统计好子数组的数目</a> | 中等 </li><li><a href="https://leetcode.cn/contest/weekly-contest-328/problems/difference-between-maximum-and-minimum-price-sum/">最大价值和与最小价值和的差值</a> | 困难</details></li></ol><h2 id="第-1-题-数组元素和与数字和的绝对差"><a href="#第-1-题-数组元素和与数字和的绝对差" class="headerlink" title="第 1 题 - 数组元素和与数字和的绝对差"></a>第 1 题 - 数组元素和与数字和的绝对差</h2><details>  <summary>点击显示题目</summary><p>给你一个正整数数组 <code>nums</code> 。</p><ul>    <li><strong>元素和</strong> 是 <code>nums</code> 中的所有元素相加求和。</li>    <li><strong>数字和</strong> 是&nbsp;<code>nums</code> 中每一个元素的每一数位（重复数位需多次求和）相加求和。</li></ul><p>返回 <strong>元素和</strong> 与 <strong>数字和</strong> 的绝对差。</p><p><strong>注意：</strong>两个整数 <code>x</code> 和 <code>y</code> 的绝对差定义为 <code>|x - y|</code> 。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [1,15,6,3]<strong>输出：</strong>9<strong>解释：</strong>nums 的元素和是 1 + 15 + 6 + 3 = 25 。nums 的数字和是 1 + 1 + 5 + 6 + 3 = 16 。元素和与数字和的绝对差是 |25 - 16| = 9 。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [1,2,3,4]<strong>输出：</strong>0<strong>解释：</strong>nums 的元素和是 1 + 2 + 3 + 4 = 10 。nums 的数字和是 1 + 2 + 3 + 4 = 10 。元素和与数字和的绝对差是 |10 - 10| = 0 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= nums.length &lt;= 2000</code></li>    <li><code>1 &lt;= nums[i] &lt;= 2000</code></li></ul></details><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>没有什么说的，签到题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">differenceOfSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>s, d := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>s += v<br><span class="hljs-keyword">for</span> v &gt; <span class="hljs-number">0</span> &#123;<br>d += v % <span class="hljs-number">10</span><br>v /= <span class="hljs-number">10</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> s-d &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> d - s<br>&#125;<br><span class="hljs-keyword">return</span> s - d<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第-2-题-子矩阵元素加-1"><a href="#第-2-题-子矩阵元素加-1" class="headerlink" title="第 2 题 - 子矩阵元素加 1"></a>第 2 题 - 子矩阵元素加 1</h2><blockquote><p>其实两道 中等题 都可以上难度的，第二题上难度就是增大数据范围，但依然是板子题，就是需要记板子。<br>周赛现推是不大够时间的。</p></blockquote><details>  <summary>点击显示题目</summary><p>给你一个正整数 <code>n</code> ，表示最初有一个 <code>n x n</code> 、下标从 <strong>0</strong> 开始的整数矩阵 <code>mat</code> ，矩阵中填满了 0 。</p><p>另给你一个二维整数数组 <code>query</code> 。针对每个查询 <code>query[i] = [row1<sub>i</sub>, col1<sub>i</sub>, row2<sub>i</sub>, col2<sub>i</sub>]</code> ，请你执行下述操作：</p><ul>    <li>找出 <strong>左上角</strong> 为 <code>(row1<sub>i</sub>, col1<sub>i</sub>)</code> 且 <strong>右下角</strong> 为 <code>(row2<sub>i</sub>, col2<sub>i</sub>)</code> 的子矩阵，将子矩阵中的 <strong>每个元素</strong> 加 <code>1</code> 。也就是给所有满足 <code>row1<sub>i</sub> &lt;= x &lt;= row2<sub>i</sub></code> 和 <code>col1<sub>i</sub> &lt;= y &lt;= col2<sub>i</sub></code> 的 <code>mat[x][y]</code> 加 <code>1</code> 。</li></ul><p>返回执行完所有操作后得到的矩阵 <code>mat</code> 。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><p><img alt="" src="https://assets.leetcode.com/uploads/2022/11/24/p2example11.png" style="width: 531px; height: 121px;" /></p><pre><strong>输入：</strong>n = 3, queries = [[1,1,2,2],[0,0,1,1]]<strong>输出：</strong>[[1,1,0],[1,2,1],[0,1,1]]<strong>解释：</strong>上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵、执行完第二个操作后的矩阵。- 第一个操作：将左上角为 (1, 1) 且右下角为 (2, 2) 的子矩阵中的每个元素加 1 。 - 第二个操作：将左上角为 (0, 0) 且右下角为 (1, 1) 的子矩阵中的每个元素加 1 。 </pre><p><strong>示例 2：</strong></p><p><img alt="" src="https://assets.leetcode.com/uploads/2022/11/24/p2example22.png" style="width: 261px; height: 82px;" /></p><pre><strong>输入：</strong>n = 2, queries = [[0,0,1,1]]<strong>输出：</strong>[[1,1],[1,1]]<strong>解释：</strong>上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵。 - 第一个操作：将矩阵中的每个元素加 1 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= n &lt;= 500</code></li>    <li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>    <li><code>0 &lt;= row1<sub>i</sub> &lt;= row2<sub>i</sub> &lt; n</code></li>    <li><code>0 &lt;= col1<sub>i</sub> &lt;= col2<sub>i</sub> &lt; n</code></li></ul></details><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><blockquote><p>题目给出的数据量，暴力可解，但是这里给二维查分解法</p></blockquote><p><a href="https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/common.go#L591">灵茶 | 二维前缀和模板</a><br><a href="https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/common.go#L719">灵茶 | 二维查分模板</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rangeAddQueries</span><span class="hljs-params">(n <span class="hljs-type">int</span>, queries [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>a := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> a &#123;<br>a[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> queries &#123;<br>r1, c1, r2, c2 := e[<span class="hljs-number">0</span>], e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>], e[<span class="hljs-number">3</span>]<br>a[r1][c1]++<br>a[r1][c2+<span class="hljs-number">1</span>]--<br>a[r2+<span class="hljs-number">1</span>][c1]--<br>a[r2+<span class="hljs-number">1</span>][c2+<span class="hljs-number">1</span>]++<br>&#125;<br><br>ans := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ans &#123;<br>ans[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>ans[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = ans[i+<span class="hljs-number">1</span>][j] + ans[i][j+<span class="hljs-number">1</span>] - ans[i][j] + a[i][j]<br>&#125;<br>&#125;<br>ans = ans[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ans &#123;<br>ans[i] = ans[i][<span class="hljs-number">1</span>:]<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第-3-题-统计好子数组的数目"><a href="#第-3-题-统计好子数组的数目" class="headerlink" title="第 3 题 - 统计好子数组的数目"></a>第 3 题 - 统计好子数组的数目</h2><blockquote><p>第三题也是要上难度，可以把 <code>i &lt; j &amp;&amp; nums[i] == nums[j]</code> 改为 <code>i &lt; j &amp;&amp; nums[i] &lt; nums[j]</code></p></blockquote><details>  <summary>点击显示题目</summary><p>给你一个整数数组 <code>nums</code>&nbsp;和一个整数 <code>k</code>&nbsp;，请你返回 <code>nums</code>&nbsp;中 <strong>好</strong>&nbsp;子数组的数目。</p><p>一个子数组 <code>arr</code>&nbsp;如果有 <strong>至少</strong>&nbsp;<code>k</code>&nbsp;对下标 <code>(i, j)</code>&nbsp;满足 <code>i &lt; j</code>&nbsp;且 <code>arr[i] == arr[j]</code>&nbsp;，那么称它是一个 <strong>好</strong>&nbsp;子数组。</p><p><strong>子数组</strong>&nbsp;是原数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><b>输入：</b>nums = [1,1,1,1,1], k = 10<b>输出：</b>1<b>解释：</b>唯一的好子数组是这个数组本身。</pre><p><strong>示例 2：</strong></p><pre><b>输入：</b>nums = [3,1,4,3,2,2,4], k = 2<b>输出：</b>4<b>解释：</b>总共有 4 个不同的好子数组：- [3,1,4,3,2,2] 有 2 对。- [3,1,4,3,2,2,4] 有 3 对。- [1,4,3,2,2,4] 有 2 对。- [4,3,2,2,4] 有 2 对。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>    <li><code>1 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li></ul></details><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>滑动窗口：</p><ol><li>如果 <code>[l, r]</code> 满足条件，那么 <code>[l, r+1]</code> 一定满足条件</li><li>我们可以计算以 l 为起点有多少个数</li><li>固定 l，移动 r，一直找到最小的满足个数，即等于 k，此时答案有 n - r</li><li>然后向右移动 l，计算 减少 了多少 好数组</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countGood</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>n := <span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">var</span> l, r <span class="hljs-type">int</span><br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> r &lt;= n &#123;<br><span class="hljs-keyword">for</span> ; r &lt; n &amp;&amp; c &lt; k; r++ &#123;<br>c += m[nums[r]]<br>m[nums[r]]++<br>&#125;<br><span class="hljs-keyword">if</span> c &gt;= k &#123;<br>ans += n - r + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>c -= m[nums[l]] - <span class="hljs-number">1</span><br>m[nums[l]]--<br>l++<br>&#125;<br><span class="hljs-comment">// fmt.Println(l, r)</span><br><span class="hljs-keyword">return</span> <span class="hljs-type">int64</span>(ans)<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>如果把 <code>i &lt; j &amp;&amp; nums[i] == nums[j]</code> 改为 <code>i &lt; j &amp;&amp; nums[i] &lt; nums[j]</code>, 该怎样做呢?</p>          </div><blockquote><p>总体思路是不变的，关键是第 3&#x2F;4 点，如何计算移动 r&#x2F;l 时，好数组的 增加&#x2F;减少量</p></blockquote><p>思路: </p><ol><li>使用 树状数组, 维护两个树状数组，第一个维护 下标 <code>[0, l]</code>，第二个维护 <code>[0, r]</code></li><li>r 移动时，第一个树状数组求出有多少 小于 nums[r]，第二个也求出来，做差即为增加量</li><li>l 移动时，两个树状数组求出有多少 大于 nums[l]，做差即为减少量</li><li>按照原来思路滑动即可</li></ol><h2 id="第-4-题-最大价值和与最小价值和的差值"><a href="#第-4-题-最大价值和与最小价值和的差值" class="headerlink" title="第 4 题 - 最大价值和与最小价值和的差值"></a>第 4 题 - 最大价值和与最小价值和的差值</h2><details>  <summary>点击显示题目</summary><p>给你一个 <code>n</code>&nbsp;个节点的无向无根图，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你一个整数&nbsp;<code>n</code>&nbsp;和一个长度为 <code>n - 1</code>&nbsp;的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。</p><p>每个节点都有一个价值。给你一个整数数组&nbsp;<code>price</code>&nbsp;，其中&nbsp;<code>price[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的价值。</p><p>一条路径的 <strong>价值和</strong>&nbsp;是这条路径上所有节点的价值之和。</p><p>你可以选择树中任意一个节点作为根节点&nbsp;<code>root</code>&nbsp;。选择 <code>root</code>&nbsp;为根的 <strong>开销</strong>&nbsp;是以 <code>root</code>&nbsp;为起点的所有路径中，<strong>价值和</strong>&nbsp;最大的一条路径与最小的一条路径的差值。</p><p>请你返回所有节点作为根节点的选择中，<strong>最大</strong>&nbsp;的 <strong>开销</strong>&nbsp;为多少。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><p><img alt="" src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230115222431.png" style="width: 556px; height: 231px;" /></p><pre><b>输入：</b>n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]<b>输出：</b>24<b>解释：</b>上图展示了以节点 2 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。- 第一条路径节点为 [2,1,3,4]：价值为 [7,8,6,10] ，价值和为 31 。- 第二条路径节点为 [2] ，价值为 [7] 。最大路径和与最小路径和的差值为 24 。24 是所有方案中的最大开销。</pre><p><strong>示例 2：</strong></p><p><img alt="" src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230115222459.png" style="width: 352px; height: 184px;" /></p><pre><b>输入：</b>n = 3, edges = [[0,1],[1,2]], price = [1,1,1]<b>输出：</b>2<b>解释：</b>上图展示了以节点 0 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。- 第一条路径包含节点 [0,1,2]：价值为 [1,1,1] ，价值和为 3 。- 第二条路径节点为 [0] ，价值为 [1] 。最大路径和与最小路径和的差值为 2 。2 是所有方案中的最大开销。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>    <li><code>edges.length == n - 1</code></li>    <li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>    <li><code>edges</code> 表示一棵符合题面要求的树。</li>    <li><code>price.length == n</code></li>    <li><code>1 &lt;= price[i] &lt;= 10<sup>5</sup></code></li></ul></details><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>思路是两边 DFS 遍历</p><blockquote><p>有时间补上</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-1806还原排列的最少操作步数</title>
    <link href="/2023/01/09/LC-1806%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/"/>
    <url>/2023/01/09/LC-1806%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/description/?page=2">题目链接</a> | <a href="https://leetcode.cn/contest/weekly-contest-234">第 234 场单周赛</a> | <a href="https://leetcode.cn/contest/weekly-contest-234/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">Q2</a> | 难度:1491(+400)(难度取决于数据量)</p>          </div><details><summary>题目描述</summary><p>给你一个偶数 <code>n</code>​​​​​​ ，已知存在一个长度为 <code>n</code> 的排列 <code>perm</code> ，其中 <code>perm[i] == i</code>​（下标 <strong>从 0 开始</strong> 计数）。</p><p>一步操作中，你将创建一个新数组 <code>arr</code> ，对于每个 <code>i</code> ：</p><ul>    <li>如果 <code>i % 2 == 0</code> ，那么 <code>arr[i] = perm[i / 2]</code></li>    <li>如果 <code>i % 2 == 1</code> ，那么 <code>arr[i] = perm[n / 2 + (i - 1) / 2]</code></li></ul><p>然后将 <code>arr</code>​​ 赋值​​给 <code>perm</code> 。</p><p>要想使 <code>perm</code> 回到排列初始值，至少需要执行多少步操作？返回最小的 <strong>非零</strong> 操作步数。</p><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>n = 2<strong>输出：</strong>1<strong>解释：</strong>最初，perm = [0,1]第 1 步操作后，perm = [0,1]所以，仅需执行 1 步操作</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>n = 4<strong>输出：</strong>2<strong>解释：</strong>最初，perm = [0,1,2,3]第 1 步操作后，perm = [0,2,1,3]第 2 步操作后，perm = [0,1,2,3]所以，仅需执行 2 步操作</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>n = 6<strong>输出：</strong>4</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>2 <= n <= 1000</code></li>    <li><code>1800分难度:2 <= n <= 1e5 </code></li>    <li><code>n</code>​​​​​​ 是一个偶数</li></ul></details><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><blockquote><p>这道题的数学解法是直接求 欧拉函数(复杂度 $O(n)$), 可以看 <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solutions/2051628/huan-yuan-pai-lie-de-zui-shao-cao-zuo-bu-d9cn/">官方题解</a>, 这里给出使用 并查集 求环的解法, 复杂度 $O(nlgn)$.</p></blockquote><p>这道题其实就是求出所有环的大小, 求他们的最小公倍数 (lcm). 所以用 并查集 求环和其大小.<br>环其实就是一个排列的 置换, 也就是要让所有的 置换 都回归到自己的位置, 一个 置换 的一个 循环 就是 环 的大小.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reinitializePermutation</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// =======================</span><br>    <span class="hljs-comment">// find-union </span><br>fa := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>sz := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> fa &#123;<br>fa[i] = i<br>sz[i] = <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br>find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> fa[x] == x &#123;<br><span class="hljs-keyword">return</span> fa[x]<br>&#125;<br>fa[x] = find(fa[x])<br><span class="hljs-keyword">return</span> fa[x]<br>&#125;<br>merge := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> &#123;<br>fx, fy := find(x), find(y)<br><span class="hljs-keyword">if</span> fx == fy &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fa[fx] = fy<br>sz[fy] += sz[fx]<br>&#125;<br>    <span class="hljs-comment">// =======================</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> i&amp;<span class="hljs-number">1</span> == <span class="hljs-number">0</span> &#123;<br>merge(i, i/<span class="hljs-number">2</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>merge(i, n/<span class="hljs-number">2</span>+(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// 记录所有的环和其大小</span><br>r := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>r[find(i)] = sz[i]<br>&#125;<br>p := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> r &#123;<br>g := gcd(p, v)<br>p = p * v / g<br>&#125;<br><span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> gcd(b, a%b)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>环其实就是就是组合数学里的置换. 求环和其大小遇到的还挺多的.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust数据结构-Trie树</title>
    <link href="/2023/01/05/Rust%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/"/>
    <url>/2023/01/05/Rust%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文假设读者对 Trie 树有所了解，是的，一篇介绍 Trie 树的文章要求对 Trie 树有所了解。这在所难免，因为 Trie 树并不难实现。并且本文的重点在 Rust 的所有权和 unsafe 学习，以实现 Trie 树为例。</p></blockquote><blockquote><p>本文首先会介绍如何使用 safe-Rust 实现 Trie 树，然后会使用 unsafe-Rust 实现. 由于使用 unsafe-Rust 需要自己手动管理内存，需要实现 <code>Drop Triat</code>，本文会介绍 非尾递归 和 尾递归 实现 Drop，需要注意的是，非尾递归 会有较大的递归栈，因此，手动管理内存时，往往会优先选择 尾递归 方式。 </p></blockquote><blockquote><p>本文默认对 Rust 的 unsafe 有一定的了解，最好已经实现了使用 unsafe 编码实现的 链表 数据结构。本文不需要有递归方式的理解，本文会介绍 尾递归 和 非尾递归 方式，并介绍如何书写 尾递归。</p></blockquote><blockquote><p>本文介绍分数据结构为 <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">Leetcode.208实现Trie</a>, 由于 Leetcode 对 Rust 的一些传参问题，可能在实际应用中需要该参数的类型，比如把 <code>String</code> 改为 <code>&amp;str</code> 或者 <code>impl AsRef&lt;str&gt;</code> 等等以适应不同字符串的需要. 会忽略 <code>starts_with</code> 方法，只实现 <code>insert</code> 和 <code>search</code> 方法。</p></blockquote><h1 id="Safe-Rust"><a href="#Safe-Rust" class="headerlink" title="Safe-Rust"></a>Safe-Rust</h1><h2 id="设计数据结构"><a href="#设计数据结构" class="headerlink" title="设计数据结构"></a>设计数据结构</h2><p>Trie 树，又称 字典树 或 前缀树。具体描述可以查看 wiki。一颗普通的 Trie 树需要含有一下数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>    children: [<span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Trie&gt;&gt;; <span class="hljs-number">26</span>], <span class="hljs-comment">// 26个孩子节点</span><br>    is_end: <span class="hljs-type">bool</span>, <span class="hljs-comment">// 是否是一个字符串的结尾</span><br>    <span class="hljs-comment">// cnt: usize, // 经过该节点的字符串个数，有些题目需要，LC208 不需要</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Rust 中，Box 智能指针是不能为空的，因此需要使用 Option 包装一下，采用数组的方式可以比较容易的实现 Default 方法，当然也可以使用 Vec 去动态申请。但是，一般采用数组的方式更直观。</p><h2 id="实现-insert-方法"><a href="#实现-insert-方法" class="headerlink" title="实现 insert 方法"></a>实现 insert 方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>;<br>    <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>        root = root.children[b].<span class="hljs-title function_ invoke__">get_or_insert_with</span>(|| <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Trie::<span class="hljs-title function_ invoke__">new</span>()));<br>    &#125;<br>    root.is_end = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现-search-方法"><a href="#实现-search-方法" class="headerlink" title="实现 search 方法"></a>实现 search 方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>;<br>    <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> ch) = root.children[b] &#123;<br>            root = ch;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root.is_end;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现-starts-with-方法"><a href="#实现-starts-with-方法" class="headerlink" title="实现 starts_with 方法"></a>实现 starts_with 方法</h2><p>只需要把 search 方法中的 最后一行 改为 <code>return true</code> 即可。</p><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> safe_trie &#123;<br>    <span class="hljs-meta">#[derive(Default)]</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>        children: [<span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Trie&gt;&gt;; <span class="hljs-number">26</span>],<br>        is_end: <span class="hljs-type">bool</span>,<br>    &#125;<br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            &lt;Trie <span class="hljs-keyword">as</span> <span class="hljs-built_in">Default</span>&gt;::<span class="hljs-title function_ invoke__">default</span>()<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                root = root.children[b].<span class="hljs-title function_ invoke__">get_or_insert_with</span>(|| <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Trie::<span class="hljs-title function_ invoke__">new</span>()));<br>            &#125;<br>            root.is_end = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> ch) = root.children[b] &#123;<br>                    root = ch;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root.is_end;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>把 mod 去掉，然后添加上 starts_with 函数就可以提交通过了。</p></blockquote><div class="note note-primary">            <p>Safe-Rust 的实现方式是很简洁的，效率也很高，不用自己手动释放内存，实现难度也低于 unsafe 方式。但是，在更高效率需求或者一些情况所有权有很大限制的时候， unsafe 或许是唯一方式。接下来一起通过这个例子学习一下 Rust 中的 unsafe 吧。</p>          </div><h1 id="Unsafe-Rust"><a href="#Unsafe-Rust" class="headerlink" title="Unsafe-Rust"></a>Unsafe-Rust</h1><p>对于 Unsafe-Rust，其实和 c&#x2F;c++ 很像了，我们需要实现一下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> unsafe_trie &#123;<br>    <span class="hljs-keyword">use</span> std::ptr;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, word: <span class="hljs-type">String</span>) &#123;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, word: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="设计数据结构-1"><a href="#设计数据结构-1" class="headerlink" title="设计数据结构"></a>设计数据结构</h2><p>使用 <code>*mut Trie</code> 代替 <code>Option&lt;Box&lt;Trie&gt;&gt;</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>    children: [*<span class="hljs-keyword">mut</span> Trie; <span class="hljs-number">26</span>],<br>    is_end: <span class="hljs-type">bool</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>并且实现 new 方法，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>    Trie &#123;<br>        children: [ptr::<span class="hljs-title function_ invoke__">null_mut</span>(); <span class="hljs-number">26</span>],<br>        is_end: <span class="hljs-literal">false</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现-insert-方法-1"><a href="#实现-insert-方法-1" class="headerlink" title="实现 insert 方法"></a>实现 insert 方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, word: <span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> Trie;<br>    <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> word.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                (*root).children[b] = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">into_raw</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Trie::<span class="hljs-title function_ invoke__">new</span>()));<br>            &#125;<br>            root = (*root).children[b];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        (*root).is_end = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现-search-方法-1"><a href="#实现-search-方法-1" class="headerlink" title="实现 search 方法"></a>实现 search 方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, word: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> Trie;<br>    <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> word.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            root = (*root).children[b];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">unsafe</span> &#123; (*root).is_end &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现-Drop"><a href="#实现-Drop" class="headerlink" title="实现 Drop"></a>实现 Drop</h2><p>Unsafe-Rust 和 Safe-Rust 的实现思想是完全一样的，但是 Unsafe-Rust 需要实现 Drop Triat。这一章节详细介绍如何定义 Trie 树的 Drop 行为。</p><h3 id="实现-Drop-Trait"><a href="#实现-Drop-Trait" class="headerlink" title="实现 Drop Trait"></a>实现 Drop Trait</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.children &#123;<br>            <span class="hljs-keyword">if</span> !v.<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">from_raw</span>(v) &#125;;<br>                <span class="hljs-title function_ invoke__">drop</span>(b);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div style="text-align: center"><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230106173748.png" width=50% /></div>当解构时，会把所有的孩子都通过 `Box::from_raw` 把 `*mut Trie` 变为 `Box::<Trie>`，这样就可以通过 Rust 数据结构而释放 原生指针 申请的内存。<details >  <summary>完整代码-点击查看</summary><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> unsafe_trie &#123;<br><br>    <span class="hljs-keyword">use</span> std::ptr;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>        children: [*<span class="hljs-keyword">mut</span> Trie; <span class="hljs-number">26</span>],<br>        is_end: <span class="hljs-type">bool</span>,<br>    &#125;<br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            Trie &#123;<br>                children: [ptr::<span class="hljs-title function_ invoke__">null_mut</span>(); <span class="hljs-number">26</span>],<br>                is_end: <span class="hljs-literal">false</span>,<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, word: <span class="hljs-type">String</span>) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> Trie;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> word.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                <span class="hljs-keyword">unsafe</span> &#123;<br>                    <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                        (*root).children[b] = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">into_raw</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Trie::<span class="hljs-title function_ invoke__">new</span>()));<br>                    &#125;<br>                    root = (*root).children[b];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                (*root).is_end = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, word: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> Trie;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> word.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                <span class="hljs-keyword">unsafe</span> &#123;<br>                    <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    root = (*root).children[b];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">unsafe</span> &#123; (*root).is_end &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.children &#123;<br>                <span class="hljs-keyword">if</span> !v.<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">from_raw</span>(v) &#125;;<br>                    <span class="hljs-title function_ invoke__">drop</span>(b);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><div class="note note-primary">            <p><code>Box::into_raw</code> 和 <code>Box::from_raw</code> 是生成原生指针和释放原生指针最直接&#x2F;简单的方式。那有没有其他方式呢？其实，还有更原始的方式，以后可以专门针对 Rust 原生指针 写一篇博客详细介绍。</p>          </div><h3 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h3><p>简单来说，递归函数执行递归后可以还有部分操作，也可以没有任何操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 非尾递归</span><br><span class="hljs-function">functon <span class="hljs-title">f</span>()</span> &#123;<br>    a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 执行操作；</span><br>    f(); <span class="hljs-comment">// 进行递归</span><br>    a += <span class="hljs-number">2</span>; <span class="hljs-comment">// 递归后在执行一些操作；</span><br>&#125;<br><br><span class="hljs-comment">// 尾递归</span><br><span class="hljs-function">functon <span class="hljs-title">f</span>()</span> &#123;<br>    a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 执行操作；</span><br>    f(); <span class="hljs-comment">// 尾部进行递归</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在递归结束后还有部分操作，而且这些操作和递归前的数据有关，这些数据需要压栈，这就是非尾递归的，这种形式非常消耗递归栈。</p><p>相对的，尾递归就是递归入口在最后，执行完成递归后直接返回，没有必要在保存上一个递归函数的环境，递归栈消耗远远低于非尾递归形式。</p><h3 id="为什么这样设计数据结构不能实现尾递归"><a href="#为什么这样设计数据结构不能实现尾递归" class="headerlink" title="为什么这样设计数据结构不能实现尾递归"></a>为什么这样设计数据结构不能实现尾递归</h3><div style="text-align: center"><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230106174444.png" width=50% /></div><p>这样设计的数据结构只能是非尾递归形式释放内存。因为在释放 <code>1</code> 号节点时，会把 <code>1</code> 号节点转换成 <code>Box::&lt;Trie&gt;</code>, 然后释放 <code>1</code> 号节点，但是释放 <code>1</code> 号 节点又会执行 drop 过程，也就是是在 <code>1</code> 号节点所有孩子节点都释放之后才会释放 <code>1</code> 号节点。<br>把 drop 改为以下代码，加入打印输出，可以发现是尾递归。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">for</span> (i, v) <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.children.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>            <span class="hljs-keyword">if</span> !v.<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">from_raw</span>(v) &#125;;<br>                <span class="hljs-title function_ invoke__">drop</span>(b);<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;drop &#123;&#125;&quot;</span>, (i <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span> + <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样设计的数据结构能否改为 尾递归 的释放形式呢? 答案是不行的，因为我们仅仅定义了每个节点为 <code>Trie</code>，也就是说 一颗 字典树，是一个 <code>Trie</code> 结构体，一个字典树里的节点也是一个 <code>Trie</code>结构体。我们仅仅是为每一个 <code>Trie</code> 结构体实现 Drop Trait，这也就意味着并不能控制整个释放过程。<strong>这一点有点难理解，可以看完后面的 尾递归 形式在来看这段解释</strong>。</p><div class="note note-secondary">            <p>也就是说，要想实现尾递归，就要自己能够控制整个数据结构的释放过程。</p>          </div><h3 id="如何重新组设计数据结构"><a href="#如何重新组设计数据结构" class="headerlink" title="如何重新组设计数据结构"></a>如何重新组设计数据结构</h3><h2 id="重新设计数据结构"><a href="#重新设计数据结构" class="headerlink" title="重新设计数据结构"></a>重新设计数据结构</h2><p>如何能够控制整个数据结构的释放过程呢？实现起来也很简单，其实就在此抽象出 Trie树，把节点定义为 <code>TrieNode</code> 结构体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ptr;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>    children: [*<span class="hljs-keyword">mut</span> TrieNode; <span class="hljs-number">26</span>],<br>    is_end: <span class="hljs-type">bool</span>,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        TrieNode &#123;<br>            children: [ptr::<span class="hljs-title function_ invoke__">null_mut</span>(); <span class="hljs-number">26</span>],<br>            is_end: <span class="hljs-literal">false</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>    root: *<span class="hljs-keyword">mut</span> TrieNode,<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们抽象出了 Trie树，剥离出 节点结构体，我们就可以控制整个 Trie树 的释放过程了。</p></blockquote><h2 id="实现-insert-方法-2"><a href="#实现-insert-方法-2" class="headerlink" title="实现 insert 方法"></a>实现 insert 方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>.root;<br>    <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                (*root).children[b] = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">into_raw</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(TrieNode::<span class="hljs-title function_ invoke__">new</span>()));<br>            &#125;<br>            root = (*root).children[b];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        (*root).is_end = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现-search-方法-2"><a href="#实现-search-方法-2" class="headerlink" title="实现 search 方法"></a>实现 search 方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>.root;<br>    <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            root = (*root).children[b];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">unsafe</span> &#123; (*root).is_end &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尾递归实现-Drop"><a href="#尾递归实现-Drop" class="headerlink" title="尾递归实现 Drop"></a>尾递归实现 Drop</h2><div style="text-align: center"><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20230106195448.png" width=80% /></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clean</span>(root: *<span class="hljs-keyword">mut</span> TrieNode) &#123;<br>            <span class="hljs-keyword">if</span> root.<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">ch</span> = <span class="hljs-keyword">unsafe</span> &#123; (*root).children &#125;;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">from_raw</span>(root) &#125;;<br>            <span class="hljs-title function_ invoke__">drop</span>(b);<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">son</span> <span class="hljs-keyword">in</span> ch &#123;<br>                <span class="hljs-title function_ invoke__">clean</span>(son);<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">clean</span>(<span class="hljs-keyword">self</span>.root)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><details>  <summary>完整代码-点击查看</summary><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> unsafe_trie2 &#123;<br>    <span class="hljs-keyword">use</span> std::ptr;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        children: [*<span class="hljs-keyword">mut</span> TrieNode; <span class="hljs-number">26</span>],<br>        is_end: <span class="hljs-type">bool</span>,<br>    &#125;<br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            TrieNode &#123;<br>                children: [ptr::<span class="hljs-title function_ invoke__">null_mut</span>(); <span class="hljs-number">26</span>],<br>                is_end: <span class="hljs-literal">false</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>        root: *<span class="hljs-keyword">mut</span> TrieNode,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            Trie &#123;<br>                root: <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">into_raw</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(TrieNode::<span class="hljs-title function_ invoke__">new</span>())),<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>.root;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                <span class="hljs-keyword">unsafe</span> &#123;<br>                    <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                        (*root).children[b] = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">into_raw</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(TrieNode::<span class="hljs-title function_ invoke__">new</span>()));<br>                    &#125;<br>                    root = (*root).children[b];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                (*root).is_end = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>.root;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                <span class="hljs-keyword">unsafe</span> &#123;<br>                    <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    root = (*root).children[b];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">unsafe</span> &#123; (*root).is_end &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里加入了打印测试，可以打印输出为 确实为尾递归</span><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clean</span>(root: *<span class="hljs-keyword">mut</span> TrieNode, val: <span class="hljs-type">usize</span>) &#123;<br>                <span class="hljs-keyword">if</span> root.<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">ch</span> = <span class="hljs-keyword">unsafe</span> &#123; (*root).children &#125;;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">from_raw</span>(root) &#125;;<br>                <span class="hljs-title function_ invoke__">drop</span>(b);<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;drop &#123;&#125;&quot;</span>, (val <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span> + <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>);<br>                <span class="hljs-keyword">for</span> (val, son) <span class="hljs-keyword">in</span> ch.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>                    <span class="hljs-title function_ invoke__">clean</span>(son, val);<br>                &#125;<br>            &#125;<br>            <span class="hljs-title function_ invoke__">clean</span>(<span class="hljs-keyword">self</span>.root, <span class="hljs-number">30</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><h1 id="整合-1"><a href="#整合-1" class="headerlink" title="整合"></a>整合</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><br><span class="hljs-keyword">mod</span> safe_trie &#123;<br>    <span class="hljs-meta">#[derive(Default)]</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>        children: [<span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Trie&gt;&gt;; <span class="hljs-number">26</span>],<br>        is_end: <span class="hljs-type">bool</span>,<br>    &#125;<br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            &lt;Trie <span class="hljs-keyword">as</span> <span class="hljs-built_in">Default</span>&gt;::<span class="hljs-title function_ invoke__">default</span>()<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                root = root.children[b].<span class="hljs-title function_ invoke__">get_or_insert_with</span>(|| <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Trie::<span class="hljs-title function_ invoke__">new</span>()));<br>            &#125;<br>            root.is_end = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> ch) = root.children[b] &#123;<br>                    root = ch;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root.is_end;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">mod</span> unsafe_trie &#123;<br><br>    <span class="hljs-keyword">use</span> std::ptr;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>        children: [*<span class="hljs-keyword">mut</span> Trie; <span class="hljs-number">26</span>],<br>        is_end: <span class="hljs-type">bool</span>,<br>    &#125;<br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            Trie &#123;<br>                children: [ptr::<span class="hljs-title function_ invoke__">null_mut</span>(); <span class="hljs-number">26</span>],<br>                is_end: <span class="hljs-literal">false</span>,<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, word: <span class="hljs-type">String</span>) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> Trie;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> word.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                <span class="hljs-keyword">unsafe</span> &#123;<br>                    <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                        (*root).children[b] = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">into_raw</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Trie::<span class="hljs-title function_ invoke__">new</span>()));<br>                    &#125;<br>                    root = (*root).children[b];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                (*root).is_end = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, word: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> Trie;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> word.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                <span class="hljs-keyword">unsafe</span> &#123;<br>                    <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    root = (*root).children[b];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">unsafe</span> &#123; (*root).is_end &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">for</span> (i, v) <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.children.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>                <span class="hljs-keyword">if</span> !v.<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">from_raw</span>(v) &#125;;<br>                    <span class="hljs-title function_ invoke__">drop</span>(b);<br>                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;drop &#123;&#125;&quot;</span>, (i <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span> + <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">mod</span> unsafe_trie2 &#123;<br>    <span class="hljs-keyword">use</span> std::ptr;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        children: [*<span class="hljs-keyword">mut</span> TrieNode; <span class="hljs-number">26</span>],<br>        is_end: <span class="hljs-type">bool</span>,<br>    &#125;<br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            TrieNode &#123;<br>                children: [ptr::<span class="hljs-title function_ invoke__">null_mut</span>(); <span class="hljs-number">26</span>],<br>                is_end: <span class="hljs-literal">false</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>        root: *<span class="hljs-keyword">mut</span> TrieNode,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            Trie &#123;<br>                root: <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">into_raw</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(TrieNode::<span class="hljs-title function_ invoke__">new</span>())),<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>.root;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                <span class="hljs-keyword">unsafe</span> &#123;<br>                    <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                        (*root).children[b] = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">into_raw</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(TrieNode::<span class="hljs-title function_ invoke__">new</span>()));<br>                    &#125;<br>                    root = (*root).children[b];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                (*root).is_end = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = <span class="hljs-keyword">self</span>.root;<br>            <span class="hljs-keyword">for</span> &amp;b <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">as_bytes</span>() &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = (b - <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>                <span class="hljs-keyword">unsafe</span> &#123;<br>                    <span class="hljs-keyword">if</span> (*root).children[b].<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    root = (*root).children[b];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">unsafe</span> &#123; (*root).is_end &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clean</span>(root: *<span class="hljs-keyword">mut</span> TrieNode, val: <span class="hljs-type">usize</span>) &#123;<br>                <span class="hljs-keyword">if</span> root.<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">ch</span> = <span class="hljs-keyword">unsafe</span> &#123; (*root).children &#125;;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">from_raw</span>(root) &#125;;<br>                <span class="hljs-title function_ invoke__">drop</span>(b);<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;drop &#123;&#125;&quot;</span>, (val <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span> + <span class="hljs-string">b&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">char</span>);<br>                <span class="hljs-keyword">for</span> (val, son) <span class="hljs-keyword">in</span> ch.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>                    <span class="hljs-title function_ invoke__">clean</span>(son, val);<br>                &#125;<br>            &#125;<br>            <span class="hljs-title function_ invoke__">clean</span>(<span class="hljs-keyword">self</span>.root, <span class="hljs-number">30</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">obj</span> = unsafe_trie::Trie::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = <span class="hljs-string">&quot;oliver&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    obj.<span class="hljs-title function_ invoke__">insert</span>(w.<span class="hljs-title function_ invoke__">clone</span>());<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ret_2</span>: <span class="hljs-type">bool</span> = obj.<span class="hljs-title function_ invoke__">search</span>(w.<span class="hljs-title function_ invoke__">clone</span>());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust实现数据结构</tag>
      
      <tag>Rust unsafe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-2517礼盒的最大甜蜜度</title>
    <link href="/2023/01/03/LC-2517%E7%A4%BC%E7%9B%92%E7%9A%84%E6%9C%80%E5%A4%A7%E7%94%9C%E8%9C%9C%E5%BA%A6/"/>
    <url>/2023/01/03/LC-2517%E7%A4%BC%E7%9B%92%E7%9A%84%E6%9C%80%E5%A4%A7%E7%94%9C%E8%9C%9C%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/description/">题目链接</a> | <a href="https://leetcode.cn/contest/weekly-contest-325">第 325 场单周赛</a> | <a href="https://leetcode.cn/contest/weekly-contest-325/problems/maximum-tastiness-of-candy-basket/">Q3</a> | 难度:2021</p>          </div><details><summary>题目描述</summary><p>给你一个正整数数组 <code>price</code> ，其中 <code>price[i]</code> 表示第 <code>i</code> 类糖果的价格，另给你一个正整数 <code>k</code> 。</p><p>商店组合 <code>k</code> 类 <strong>不同</strong> 糖果打包成礼盒出售。礼盒的 <strong>甜蜜度</strong> 是礼盒中任意两种糖果 <strong>价格</strong> 绝对差的最小值。</p><p>返回礼盒的 <strong>最大 </strong>甜蜜度<em>。</em></p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>price = [13,5,1,8,21,2], k = 3<strong>输出：</strong>8<strong>解释：</strong>选出价格分别为 [13,5,21] 的三类糖果。礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。可以证明能够取得的最大甜蜜度就是 8 。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>price = [1,3,1], k = 2<strong>输出：</strong>2<strong>解释：</strong>选出价格分别为 [1,3] 的两类糖果。 礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。可以证明能够取得的最大甜蜜度就是 2 。</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>price = [7,7,7,7], k = 2<strong>输出：</strong>0<strong>解释：</strong>从现有的糖果中任选两类糖果，甜蜜度都会是 0 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= price.length &lt;= 10<sup>5</sup></code></li>    <li><code>1 &lt;= price[i] &lt;= 10<sup>9</sup></code></li>    <li><code>2 &lt;= k &lt;= price.length</code></li></ul></details><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>利用贪心性质推演出 二分判定 是这道题的主要思路. 最开始自己的思路一直被限定住了, 因为自己认为一定会选开头和结尾的元素, 如何选中间的 <code>k-2</code> 元组成为了难点, 甚至想着如果题目把 k 变成固定的 3, 那么就是个三元组就一步搞定了(笑死, 狗头永远不输). </p><p>此题正规的解法是推演出 二分判定.</p><ol><li>需要排序, 至于要不要去重, 可以但没有必要, LC 一般优化常熟没必要, 时间复杂度没变</li><li>排序后选取的最小差值一定是相邻的元素做差</li><li>第一个元素一定选取</li><li>二分判定可能的答案 <code>t</code>, 往后找元素, 直到该元组与前一个选择的元素差值大于等于 <code>t</code>, 则选择该元素</li><li>依次类推, 知道最后, 如果选择的元素 大于等于 <code>k</code>, 则认为 <code>t</code> 可行</li><li>右边界二分</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">index: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ... ]<br>        |     |        |     |<br></code></pre></td></tr></table></figure><p>举个例子, 0 元素一定选取, 然后从 1 开始判断 <code>price[r]-price[0] &gt;= t?</code> 直到选择到 2 元素, 那么在往后判断 <code>price[r]-price[2] &gt;= t?</code>  假设选择到 5 元素, 以此类推 …</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumTastiness</span><span class="hljs-params">(price []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sort.Ints(price)<br>n := <span class="hljs-built_in">len</span>(price)<br><br>check := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> l <span class="hljs-type">int</span><br>c := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> r := <span class="hljs-number">1</span>; r &lt; n; r++ &#123;<br><span class="hljs-keyword">if</span> price[r]-price[l] &gt;= t &#123;<br>l = r<br>c++<br>&#125;<br><span class="hljs-keyword">if</span> c &gt;= k &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br>l, r := <span class="hljs-number">0</span>, price[<span class="hljs-built_in">len</span>(price)<span class="hljs-number">-1</span>] - price[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> l &lt; r &#123;<br>mid := l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> check(mid) &#123;<br>l = mid  + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r = mid<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> l - <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二分判定是很巧妙的, 有时候很容易看出来, 有时候却需要转化一下, 甚至需要特意忘这方面硬想一下才能出来.</p><div class="note note-primary">            <p>做题思路还是需要体量来支撑</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC-2518好分区的数目</title>
    <link href="/2023/01/03/LC-2518%E5%A5%BD%E5%88%86%E5%8C%BA%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <url>/2023/01/03/LC-2518%E5%A5%BD%E5%88%86%E5%8C%BA%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/problems/number-of-great-partitions/description/">题目链接</a> | <a href="https://leetcode.cn/contest/weekly-contest-325">第 325 场单周赛</a> | <a href="https://leetcode.cn/contest/weekly-contest-325/problems/number-of-great-partitions/">Q4</a> | 难度:2415</p>          </div><details><summary>题目描述</summary><p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p><strong>分区</strong> 的定义是：将数组划分成两个有序的 <strong>组</strong> ，并满足每个元素 <strong>恰好</strong> 存在于 <strong>某一个</strong> 组中。如果分区中每个组的元素和都大于等于 <code>k</code> ，则认为分区是一个好分区。</p><p>返回 <strong>不同</strong> 的好分区的数目。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p><p>如果在两个分区中，存在某个元素 <code>nums[i]</code> 被分在不同的组中，则认为这两个分区不同。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [1,2,3,4], k = 4<strong>输出：</strong>6<strong>解释：</strong>好分区的情况是 ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) 和 ([4], [1,2,3]) 。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [3,3,3], k = 4<strong>输出：</strong>0<strong>解释：</strong>数组中不存在好分区。</pre><p><strong class="example">示例 3：</strong></p><pre><strong>输入：</strong>nums = [6,6], k = 2<strong>输出：</strong>2<strong>解释：</strong>可以将 nums[0] 放入第一个分区或第二个分区中。好分区的情况是 ([6], [6]) 和 ([6], [6]) 。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= nums.length, k &lt;= 1000</code></li>    <li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li></ul></details><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>这道题思维难点在 Leetcode 平台还是有的, 过了组合计数的思维转换, 这就是一个基础 0&#x2F;1背包 问题了.</p><blockquote><p>同时满足两个分组的元素都大于 k, 其实互斥条件就是 至少存在一个分组和小于 k.<br>正向比较难求, 逆向求<strong>至少存在一个分组和小于 k 的个数</strong>, 然后用总数去做差就好.</p></blockquote><h3 id="什么时候没有答案"><a href="#什么时候没有答案" class="headerlink" title="什么时候没有答案"></a>什么时候没有答案</h3><p>这一点也是很重要的, 必须提前判断. 因为要求两个分组和都大于 k, 那么如果 <code>2 * sum(nums) &lt; k</code> 的话, 那一定是没有答案的, 直接返回 0 即可. 其他情况一定是有答案的.</p><h3 id="如何求总数"><a href="#如何求总数" class="headerlink" title="如何求总数"></a>如何求总数</h3><p>这个是很简单的, 就是 $2^n$ 假设有 n 个数字的话.</p><h3 id="如何求-至少存在一个分组和小于-k-的数目"><a href="#如何求-至少存在一个分组和小于-k-的数目" class="headerlink" title="如何求 至少存在一个分组和小于 k 的数目"></a>如何求 至少存在一个分组和小于 k 的数目</h3><p>抽象成一个 0&#x2F;1 背包问题, 有 n 个数, 背包容量为 <code>k-1</code>, 求有多少个组合数使得不超过背包容量.<br>这只是求得一个分组和小于 k 的个数, 在乘上 2, 就得到了至少一个分组和小于 k 的个数.</p><blockquote><p>这为什么正确呢? 按照容斥原理, 求 <code>至少分在一个分组和小于 k</code> 应该还要减去 <code>两个分组和都小于 k</code> 的情况. 但是这种情况在判断 有没有答案的时候 已经排除掉了, 所以是 0.</p></blockquote><div class="note note-primary">            <p>这样进行做差就得到了, 题目要求的两个分组同时大于等于 k 的情况.</p>          </div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> MOD <span class="hljs-type">int</span> = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pack</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, m <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 容量 恰好 为 j 的方案数为 f[j]</span><br>f := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> nums &#123;<br><span class="hljs-keyword">for</span> j := m; j &gt;= c; j-- &#123;<br>f[j] = (f[j] + f[j-c]) % MOD<br>&#125;<br>&#125;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= m; i++ &#123;<br>c = (c + f[i]) % MOD<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// 0/1 背包也可以这样写</span><br><span class="hljs-comment">// func pack(nums []int, m int) int &#123;</span><br><span class="hljs-comment">//  // 容量 至多 为 j 的方案数为 f[j] </span><br><span class="hljs-comment">// f := make([]int, m+1)</span><br><span class="hljs-comment">// for i := range f &#123;</span><br><span class="hljs-comment">// f[i] = 1</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// for _, c := range nums &#123;</span><br><span class="hljs-comment">// for j := m; j &gt;= c; j-- &#123;</span><br><span class="hljs-comment">// f[j] = (f[j] + f[j-c]) % MOD</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// return f[m]</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPartitions</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>s := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>s += v<br>&#125;<br><span class="hljs-keyword">if</span> s &lt; k*<span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br>ans := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>ans = (ans &lt;&lt; <span class="hljs-number">1</span>) % MOD<br>&#125;<br>b := pack(nums, k<span class="hljs-number">-1</span>) * <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> (ans - b + MOD) % MOD<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 这是一道需要组合计数进行思维转换的题目. 如果不在转换真的就麻烦了. 一道难题可能就是很多小小的点组成的, 每一个点可能都是中等难度, 但是只要一个点想不出来, 这道题就是货真价实的难题了.</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust-数据比较和排序</title>
    <link href="/2022/12/31/Rust-%E6%95%B0%E6%8D%AE%E6%AF%94%E8%BE%83%E5%92%8C%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/12/31/Rust-%E6%95%B0%E6%8D%AE%E6%AF%94%E8%BE%83%E5%92%8C%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在刷算法题的时候, 经常会遇到<strong>复合数据结构</strong>, 有时候又要求这些数据结构可以根据某种规则排序和比较. 需要快速按照正确的思路进行编码, 这就需要熟练掌握 Rust 中的数据结构比较和排序规则.</p></blockquote><div class="note note-primary">            <p>这篇文章会尝试探讨 Rust 中的排序和比较规则. 因为排序需要用到比较, 因此下文单指 排序 时, 也默认包含 比较 规则.</p>          </div><ol><li>元组的排序规则是什么. 因为 Rust 中的 孤儿原则, 不能给元组实现标准库的 Trait, 只能按照 Rust 中对元组的规则进行.</li><li>自己定义的 复合数据结构, 要想实现排序规则, 需要实现哪些 Trait, 又各自有哪些作用.</li><li><code>sort_by</code>, <code>sort_by_key</code> 如何定义闭包函数.</li><li><code>BTreeSet</code>, <code>BTreeMap</code> 如何使用并提供自己定义的数据结构支持.</li><li><code>BinaryHeap</code> 默认是 大顶堆 , 那如何实现 小顶堆, 如何提供自己定义的数据结构支持.</li></ol><p>带着这些问题, 让我们深入 Rust 的比较和排序规则吧.</p><h1 id="Rust-比较"><a href="#Rust-比较" class="headerlink" title="Rust 比较"></a>Rust 比较</h1><h2 id="std-cmp-模块"><a href="#std-cmp-模块" class="headerlink" title="std::cmp 模块"></a>std::cmp 模块</h2><p><a href="https://doc.rust-lang.org/std/cmp/index.html"><code>std::cmp</code></a> 是 Rust 提供比较的模块. 如果你熟悉其他编程语言, 像 c&#x2F;cpp, golang, python等等, 可能会怀疑为什么要为比较单独写一个库, 而不是像 cpp 那样给 一个 struct 写一个 cmp 函数.<br>并且, Rust 的比较并不是 bool 类型, 而是一个 枚举类型. 这一点的好处便是在项目工程代码中特别直观, 不好的地方就是在 算法竞赛方面要比其他语言多写一些代码, 时间上要多花费一些, 因此要更熟悉一些要好.</p><h3 id="Enums-Ordering"><a href="#Enums-Ordering" class="headerlink" title="[Enums] Ordering"></a>[Enums] Ordering</h3><p>Rust 使用枚举体 <a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html">Ordering</a> 反应比较的大小.<br>这个枚举体会在后面的方法或函数或闭包中用到.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Ordering</span> &#123;<br>    Less,<br>    Equal,<br>    Greater,<br>&#125;<br></code></pre></td></tr></table></figure><p>Ordering 枚举体有三个 Variants, 分别代表比较的结果, 执行 <code>a.cmp(b)</code> :</p><ol><li><code>a &lt; b</code> : 返回 <code>Ordering::Less</code></li><li><code>a = b</code> : 返回 <code>Ordering::Equal</code></li><li><code>a &gt; b</code> : 返回 <code>Ordering::Greater</code></li></ol><div class="note note-primary">            <p>Ordering 枚举体往往作为核心函数的返回值进行比较判断</p>          </div><h4 id="Ordering-类型可以转换为-bool-类型"><a href="#Ordering-类型可以转换为-bool-类型" class="headerlink" title="Ordering 类型可以转换为 bool 类型"></a>Ordering 类型可以转换为 bool 类型</h4><p>Rust 为 Ordering 枚举体实现了一些方法, 可以将 Ordering 转换为 bool.<br>判断并转为 bool 方法: <code>is_eq</code>, <code>is_ge</code>, <code>is_gt</code>, <code>is_le</code>, <code>is_lt</code>, <code>is_ne</code><br>还有反转函数: <code>reverse</code></p><h3 id="Trait-PartialEq"><a href="#Trait-PartialEq" class="headerlink" title="[Trait] PartialEq"></a>[Trait] PartialEq</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">PartialEq</span>&lt;Rhs = <span class="hljs-keyword">Self</span>&gt;<br><span class="hljs-keyword">where</span><br>    Rhs: ?<span class="hljs-built_in">Sized</span>,<br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eq</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ne</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"> PartialEq </a> 是 Rust 提供的偏等关系, 有默认实现方法 ne, 但需要实现 eq 函数.</p>          </div><blockquote><p>a &#x3D;&#x3D; b 是 a.eq(b) 的语法糖; a !&#x3D; b 是 a.ne(b) 的语法糖. 什么是偏等关系呢, 其实就是不保证 a &#x3D;&#x3D; a, 所有的整型数据都是全等的, 浮点型是偏等的, 只是因为 NaN !&#x3D; NaN. 也就是说 PartialEq 不保证自反性</p></blockquote><p>PartialEq 是一个泛型Trait, 这意味着可以实现两个不同的数据结构的判等.</p><h3 id="Trait-Eq"><a href="#Trait-Eq" class="headerlink" title="[Trait] Eq"></a>[Trait] Eq</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Eq</span>: <span class="hljs-built_in">PartialEq</span>&lt;<span class="hljs-keyword">Self</span>&gt; &#123; &#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>可以看到, <a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a> 就是简单承接自 PartialEq, 这意味着如果实现了 PartialEq 并且保证是全等关系(保证 自反性), 实现 Eq 不需要实现任何方法.</p>          </div><p>举个例子:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">BookFormat</span> &#123; Paperback, Hardback, Ebook &#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Book</span> &#123;<br>    isbn: <span class="hljs-type">i32</span>,<br>    format: BookFormat,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialEq</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eq</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.isbn == other.isbn<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Eq</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Book</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="Trait-PartialOrd"><a href="#Trait-PartialOrd" class="headerlink" title="[Trait] PartialOrd"></a>[Trait] PartialOrd</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">PartialOrd</span>&lt;Rhs = <span class="hljs-keyword">Self</span>&gt;: <span class="hljs-built_in">PartialEq</span>&lt;Rhs&gt;<br><span class="hljs-keyword">where</span><br>    Rhs: ?<span class="hljs-built_in">Sized</span>,<br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">partial_cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Ordering&gt;;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lt</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123; ... &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">le</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123; ... &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">gt</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123; ... &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ge</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html">PartialOrd</a> 是 Rust 提供的偏序关系, 需要实现 partial_cmp 方法, 其他方法有默认实现. partial_cmp 返回的是 Option<Ordering>.</p>          </div><blockquote><p>关于偏序关系, 可以查看 <a href="https://en.wikipedia.org/wiki/Partially_ordered_set#Partial_order"> wiki </a>, 但是有个比较直观的理解: 偏序关系 不保证所有的元素都可以比较大小, 而 全序关系 需要保证所有排序的元素都可以比较.</p></blockquote><div class="note note-secondary">            <p>实现 PartialOrd 需要 实现 PartialEq, 并且依然是 泛型Trait, 意味着可以进行两个不同类型的比较.</p>          </div><h3 id="Trait-Ord"><a href="#Trait-Ord" class="headerlink" title="[Trait] Ord"></a>[Trait] Ord</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Ord</span>: <span class="hljs-built_in">Eq</span> + <span class="hljs-built_in">PartialOrd</span>&lt;<span class="hljs-keyword">Self</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> Ordering;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">max</span>(<span class="hljs-keyword">self</span>, other: <span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span><br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>,<br>    &#123; ... &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">min</span>(<span class="hljs-keyword">self</span>, other: <span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span><br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>,<br>    &#123; ... &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clamp</span>(<span class="hljs-keyword">self</span>, min: <span class="hljs-keyword">Self</span>, max: <span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span><br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">PartialOrd</span>&lt;<span class="hljs-keyword">Self</span>&gt;,<br>    &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"> Ord </a> 是 Rust 提供的全序关系, 和 PartialOrd 唯一的区别是需要实现的 cmp 方法返回值是 Ordering, 这也意味着保证了所有元素都是可比较的, 因此 cmp 不会返回 Option.</p>          </div><blockquote><p>使用到的 BTreeSet&#x2F;BTreeMap 和 BinaryHeap 都需要实现到 Ord Trait, 因此比赛设计的数据结构一般也需要实现到 Ord Trait.</p></blockquote><h3 id="Struct-Reverse"><a href="#Struct-Reverse" class="headerlink" title="[Struct] Reverse"></a>[Struct] Reverse</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Reverse</span>&lt;T&gt;(<span class="hljs-keyword">pub</span> T);<br></code></pre></td></tr></table></figure><p>这是一个 Rust 提供的反转默认比较结果的元组结构体.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (a, b) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">assert_eq!</span>(a.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b), Ordering::Less);<br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Reverse</span>(a).<span class="hljs-title function_ invoke__">cmp</span>(&amp;<span class="hljs-title function_ invoke__">Reverse</span>(b)), Ordering::Greater);<br></code></pre></td></tr></table></figure><h2 id="复合数据结构比较"><a href="#复合数据结构比较" class="headerlink" title="复合数据结构比较"></a>复合数据结构比较</h2><h3 id="元组比较"><a href="#元组比较" class="headerlink" title="元组比较"></a>元组比较</h3><p>Rust 元组排序是没有办法自定义的, 只能根据 Rust 提供的规则进行:</p><ol><li>两个元组能比较, 需要两个元组具有相同结构, 即相同参数个数和类型.</li><li>两个元组能进行偏序(partial_cmp)比较, 需要满足 第一条 并且 元素都实现 PartialOrd Trait.</li><li>两个元组能进行全序(cmp)比较, 需要满足 第一条 并且 元素都实现 Ord Trait.</li><li>可以使用 Reverse 结构体反转 部分 元素.</li><li>可以使用 Reverse 结构体反转 全部 元素.</li></ol><p>下面将举一些例子进行阐述:</p><h4 id="1-两个元组能比较-需要两个元组具有相同结构-即相同参数个数和类型"><a href="#1-两个元组能比较-需要两个元组具有相同结构-即相同参数个数和类型" class="headerlink" title="1. 两个元组能比较, 需要两个元组具有相同结构, 即相同参数个数和类型"></a>1. 两个元组能比较, 需要两个元组具有相同结构, 即相同参数个数和类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">cmp</span>(&amp;(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));      <span class="hljs-comment">// ok</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">cmp</span>(&amp;(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));   <span class="hljs-comment">// error: 参数个数不匹配</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">2i64</span>).<span class="hljs-title function_ invoke__">cmp</span>(&amp;(<span class="hljs-number">2</span>, <span class="hljs-number">3u8</span>)); <span class="hljs-comment">// error: 参数类型不匹配</span><br></code></pre></td></tr></table></figure><h4 id="2-两个元组能进行偏序-partial-cmp-比较-需要满足-第一条-并且-元素都实现-PartialOrd-Trait"><a href="#2-两个元组能进行偏序-partial-cmp-比较-需要满足-第一条-并且-元素都实现-PartialOrd-Trait" class="headerlink" title="2. 两个元组能进行偏序(partial_cmp)比较, 需要满足 第一条 并且 元素都实现 PartialOrd Trait"></a>2. 两个元组能进行偏序(partial_cmp)比较, 需要满足 第一条 并且 元素都实现 PartialOrd Trait</h4><h4 id="3-两个元组能进行全序-cmp-比较-需要满足-第一条-并且-元素都实现-Ord-Trait"><a href="#3-两个元组能进行全序-cmp-比较-需要满足-第一条-并且-元素都实现-Ord-Trait" class="headerlink" title="3. 两个元组能进行全序(cmp)比较, 需要满足 第一条 并且 元素都实现 Ord Trait."></a>3. 两个元组能进行全序(cmp)比较, 需要满足 第一条 并且 元素都实现 Ord Trait.</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">partial_cmp</span>(&amp;(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>));       <span class="hljs-comment">// ok</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">cmp</span>(&amp;(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>));               <span class="hljs-comment">// ok</span><br><br>(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>).<span class="hljs-title function_ invoke__">partial_cmp</span>(&amp;(<span class="hljs-number">1</span>, <span class="hljs-number">3.0</span>));   <span class="hljs-comment">//ok</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>).<span class="hljs-title function_ invoke__">cmp</span>(&amp;(<span class="hljs-number">1</span>, <span class="hljs-number">3.0</span>));           <span class="hljs-comment">// error: 浮点数没有实现 Ord Trait, 不能进行全序比较</span><br></code></pre></td></tr></table></figure><h4 id="4-可以使用-Reverse-结构体反转-部分-元素"><a href="#4-可以使用-Reverse-结构体反转-部分-元素" class="headerlink" title="4. 可以使用 Reverse 结构体反转 部分 元素."></a>4. 可以使用 Reverse 结构体反转 部分 元素.</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">assert_eq!</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">cmp</span>(&amp;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)), Ordering::Greater);<br><span class="hljs-built_in">assert_eq!</span>((<span class="hljs-number">1</span>, <span class="hljs-title function_ invoke__">Reverse</span>(<span class="hljs-number">2</span>)).<span class="hljs-title function_ invoke__">cmp</span>(&amp;(<span class="hljs-number">1</span>, <span class="hljs-title function_ invoke__">Reverse</span>(<span class="hljs-number">1</span>))), Ordering::Less);<br></code></pre></td></tr></table></figure><h4 id="5-可以使用-Reverse-结构体反转-全部-元素"><a href="#5-可以使用-Reverse-结构体反转-全部-元素" class="headerlink" title="5. 可以使用 Reverse 结构体反转 全部 元素."></a>5. 可以使用 Reverse 结构体反转 全部 元素.</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">assert_eq!</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">cmp</span>(&amp;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)), Ordering::Greater);<br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Reverse</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).<span class="hljs-title function_ invoke__">cmp</span>(&amp;(<span class="hljs-title function_ invoke__">Reverse</span>((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)))), Ordering::Less);<br></code></pre></td></tr></table></figure><h3 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h3><p>一般结构体没有浮点类型的话, 是可以实现到 Ord Trait 的. 要想实现 Ord Trait, 也就要实现 PartialEq, Eq, PartialOrd 这三个 Trait.<br>举个官方文档的例子:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><br><span class="hljs-meta">#[derive(Eq)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    id: <span class="hljs-type">u32</span>,<br>    name: <span class="hljs-type">String</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Ord</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> Ordering &#123;<br>        <span class="hljs-keyword">self</span>.height.<span class="hljs-title function_ invoke__">cmp</span>(&amp;other.height)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialOrd</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">partial_cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Ordering&gt; &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">cmp</span>(other))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialEq</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eq</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.height == other.height<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>后面会介绍 结合 BTreeSet&#x2F;BTreeMap 和 BinaryHeap 的例子.</p></blockquote><h1 id="Sort-排序"><a href="#Sort-排序" class="headerlink" title="Sort 排序"></a>Sort 排序</h1><p>Rust 为可变切片提供的排序支持, sort* 为稳定排序, 实现为归并排序, unstable_sort* 为不稳定排序, 实现为快排的变形. 一般做题只需要使用 不稳定 的就好, 因为平均常数小很多. 但是这里使用 sort* 辅助描述排序规则.</p><div class="note note-primary">            <p>Rust 中 sort* 和 unstable_sort* 都是 从小到大 进行排序. 即都是从 Ordering::Less 到 Ordering::Greater.</p>          </div><h2 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h2><p>最基本的排序, 从小到大 排.<br>排序结果若为 <code>[a, b, c]</code>, 那么:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">a.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b) <span class="hljs-punctuation">-&gt;</span> Ordering::Less<br>b.<span class="hljs-title function_ invoke__">cmp</span>(&amp;c) <span class="hljs-punctuation">-&gt;</span> Ordering::Less<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>s.<span class="hljs-title function_ invoke__">sort</span>();<br><span class="hljs-built_in">assert_eq!</span>(s, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br></code></pre></td></tr></table></figure><h2 id="sort-by-排序"><a href="#sort-by-排序" class="headerlink" title="sort_by 排序"></a>sort_by 排序</h2><p>根据排序函数比较结果进行排序</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sort_by</span>&lt;F&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, compare: F)<br><span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnMut</span>(&amp;T, &amp;T) <span class="hljs-punctuation">-&gt;</span> Ordering,<br></code></pre></td></tr></table></figure><p>可以发现该闭包函数接受两个参数, 分别代表两个元素, 第一个设为 first, 第二个为 second.</p><ol><li>如果 闭包函数 返回 Ordering::Less, 那么 排序结果将为 [first, second];</li><li>如果 闭包函数 返回 Ordering::Greater, 那么 排序结果将为 [second, first];</li><li>如果 闭包函数 返回 Ordering::Equal, 那么稳定排序则一定按照顺序, 不稳定排序不保证顺序.</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>s.<span class="hljs-title function_ invoke__">sort_by</span>(|a, b| a.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b));<br><span class="hljs-built_in">assert_eq!</span>(s, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br></code></pre></td></tr></table></figure><p>那如何利用 sort_by 函数从到到小排序呢? 根据上述三条规则, 很容易设计出一些满足的方法:<br>下面给出是是三个方式, 核心思想都是 <strong>反转前后比较结果</strong>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>s.<span class="hljs-title function_ invoke__">sort_by</span>(|a, b| <span class="hljs-keyword">match</span> a.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b) &#123;<br>    Ordering::Less =&gt; Ordering::Greater,<br>    Ordering::Equal =&gt; Ordering::Equal,<br>    Ordering::Greater =&gt; Ordering::Less,<br>&#125;);<br><span class="hljs-built_in">assert_eq!</span>(s, [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>s.<span class="hljs-title function_ invoke__">sort_by</span>(|a, b| b.<span class="hljs-title function_ invoke__">cmp</span>(&amp;a));<br><span class="hljs-built_in">assert_eq!</span>(s, [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>s.<span class="hljs-title function_ invoke__">sort_by</span>(|a, b| <span class="hljs-title function_ invoke__">Reverse</span>(a).<span class="hljs-title function_ invoke__">cmp</span>(&amp;<span class="hljs-title function_ invoke__">Reverse</span>(b)));<br><span class="hljs-built_in">assert_eq!</span>(s, [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><h2 id="sort-by-key-排序"><a href="#sort-by-key-排序" class="headerlink" title="sort_by_key 排序"></a>sort_by_key 排序</h2><p>Rust 提供的根据一个键值key 进行排序. 闭包函数要做的就是把一个元素转为一个实现 Ord Trait 的 key.<br>然后 Rust 会根据 key 值 从小到大 进行排序.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sort_by_key</span>&lt;K, F&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, f: F)<br><span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnMut</span>(&amp;T) <span class="hljs-punctuation">-&gt;</span> K,<br>    K: <span class="hljs-built_in">Ord</span>,<br></code></pre></td></tr></table></figure><p><strong>使用 sort_by_key 实现从小到大排序</strong>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>s.<span class="hljs-title function_ invoke__">sort_by_key</span>(|v| -v);<br><span class="hljs-built_in">assert_eq!</span>(s, [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>s.<span class="hljs-title function_ invoke__">sort_by_key</span>(|v| <span class="hljs-title function_ invoke__">Reverse</span>(*v));<br><span class="hljs-built_in">assert_eq!</span>(s, [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><h1 id="Rust-需要设计排序数据结构"><a href="#Rust-需要设计排序数据结构" class="headerlink" title="Rust 需要设计排序数据结构"></a>Rust 需要设计排序数据结构</h1><p>其实这块和 Sort 排序类似, 只需要明白各自的数据结构是按照什么规则进行排序的.</p><h2 id="BTreeset-BTreeMap-平衡树"><a href="#BTreeset-BTreeMap-平衡树" class="headerlink" title="BTreeset&#x2F;BTreeMap 平衡树"></a>BTreeset&#x2F;BTreeMap 平衡树</h2><p>平衡树是从小到大排的. 所以，平衡树和排序是很像的.</p><p>一个简单的例子:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::BTreeSet;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b</span> = BTreeSet::<span class="hljs-title function_ invoke__">from</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-built_in">assert_eq!</span>(b.<span class="hljs-title function_ invoke__">into_iter</span>().collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;(), [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br></code></pre></td></tr></table></figure><p>我们设计一个三元组结构体, 该结构体的比较规则仅仅按照中间元素进行判断.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialEq</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eq</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> == other.<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span> == other.<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">self</span>.<span class="hljs-number">2</span> == other.<span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Eq</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Pair</span> &#123;&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Ord</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> Ordering &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">1</span>.<span class="hljs-title function_ invoke__">cmp</span>(&amp;other.<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PartialOrd</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">partial_cmp</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Ordering&gt; &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">cmp</span>(other))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b</span>: BTreeSet&lt;Pair&gt; = BTreeSet::<span class="hljs-title function_ invoke__">new</span>();<br>b.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-title function_ invoke__">Pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>b.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-title function_ invoke__">Pair</span>(<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br>b.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-title function_ invoke__">Pair</span>(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>));<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, b);<br><span class="hljs-comment">// -- 输出</span><br><span class="hljs-comment">// &#123;Pair(9, 1, 4), Pair(1, 2, 3), Pair(7, 4, 2)&#125;</span><br></code></pre></td></tr></table></figure><h2 id="BinaryHeap-堆"><a href="#BinaryHeap-堆" class="headerlink" title="BinaryHeap 堆"></a>BinaryHeap 堆</h2><p>Rust 提供的优先队列, 默认大顶堆.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::BinaryHeap;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b</span> = BinaryHeap::<span class="hljs-title function_ invoke__">from</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]);<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(peak) = b.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\t&quot;</span>, peak);<br>&#125;<br><span class="hljs-comment">// -- 输出</span><br><span class="hljs-comment">// 5   4   3   2   1</span><br></code></pre></td></tr></table></figure><blockquote><p>那如何实现小顶堆呢? 根据前面的讲述, 这里应该有思路了, 留作读者思考.</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>sort 按照 <code>Ordering::Less -&gt; Ordering::Greater</code></li><li>BTreeSet&#x2F;BTreeMap 按照 <code>Ordering::Less -&gt; Ordering::Greater</code></li><li>BinaryHeap按照 <code>Ordering::Greater -&gt; Ordering::Less</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC.1697.检查边长度限制的路径是否存在</title>
    <link href="/2022/12/14/LC-1697-%E6%A3%80%E6%9F%A5%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"/>
    <url>/2022/12/14/LC-1697-%E6%A3%80%E6%9F%A5%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/">题目链接</a> | <a href="https://leetcode.cn/contest/weekly-contest-220">第 220 场双周赛</a> | <a href="https://leetcode.cn/contest/weekly-contest-220/problems/checking-existence-of-edge-length-limited-paths/">Q4</a> | 难度:2300</p>          </div><details><summary>题目描述</summary><p>给你一个 <code>n</code> 个点组成的无向图边集 <code>edgeList</code> ，其中 <code>edgeList[i] = [u<sub>i</sub>, v<sub>i</sub>, dis<sub>i</sub>]</code> 表示点 <code>u<sub>i</sub></code> 和点 <code>v<sub>i</sub></code> 之间有一条长度为 <code>dis<sub>i</sub></code> 的边。请注意，两个点之间可能有 <strong>超过一条边 </strong>。</p><p>给你一个查询数组<code>queries</code> ，其中 <code>queries[j] = [p<sub>j</sub>, q<sub>j</sub>, limit<sub>j</sub>]</code> ，你的任务是对于每个查询 <code>queries[j]</code> ，判断是否存在从 <code>p<sub>j</sub></code> 到 <code>q<sub>j</sub></code><sub> </sub>的路径，且这条路径上的每一条边都 <strong>严格小于</strong> <code>limit<sub>j</sub></code> 。</p><p>请你返回一个 <b>布尔数组</b><em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer.length == queries.length</code> ，当 <code>queries[j]</code> 的查询结果为 <code>true</code> 时， <code>answer</code> 第<em> </em><code>j</code> 个值为<em> </em><code>true</code><em> </em>，否则为 <code>false</code> 。</p><p> </p><p><strong>示例 1：</strong></p><img alt="" src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20221214092538.png" style="width: 267px; height: 262px;" /><pre><b>输入：</b>n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]<b>输出：</b>[false,true]<b>解释：</b>上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。对于第二个查询，有一条路径（0 -> 1 -> 2）两条边都小于 5 ，所以这个查询我们返回 true 。</pre><p><strong>示例 2：</strong></p><img alt="" src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20221214092610.png" style="width: 390px; height: 358px;" /><pre><b>输入：</b>n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]<b>输出：</b>[true,false]<b>解释：</b>上图为给定数据。</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>2 <= n <= 10<sup>5</sup></code></li>    <li><code>1 <= edgeList.length, queries.length <= 10<sup>5</sup></code></li>    <li><code>edgeList[i].length == 3</code></li>    <li><code>queries[j].length == 3</code></li>    <li><code>0 <= u<sub>i</sub>, v<sub>i</sub>, p<sub>j</sub>, q<sub>j</sub> <= n - 1</code></li>    <li><code>u<sub>i</sub> != v<sub>i</sub></code></li>    <li><code>p<sub>j</sub> != q<sub>j</sub></code></li>    <li><code>1 <= dis<sub>i</sub>, limit<sub>j</sub> <= 10<sup>9</sup></code></li>    <li>两个点之间可能有 <strong>多条</strong> 边。</li></ul></details><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>看到这个题第一感觉是最短路，用 dijkstra 算法扫一边，在用在线算法去求解，但是很可惜，这道题的询问并不是固定某个点的，所以用 dijkstra 扫描没有用。<br>那么询问连通图问题，只能用并查集了，并且要当成离线算法处理。</p><p><font color=#95E1D3 size=4>最重要离线思路：</font></p><div class="note note-primary">            <p>对一个 query，那么把所有 edges 的长度小于此 limit 的边都连起来，然后判断 query 的两个点是否连通。</p>          </div><blockquote><p>这要求 edges 和 queries 要按照 limit 从小到大排序。</p></blockquote><h4 id="强行在线算法"><a href="#强行在线算法" class="headerlink" title="强行在线算法"></a>强行在线算法</h4><p>如果使用在线算法会变得很麻烦，需要 <strong>树上倍增 + LCA</strong>， <a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/solution/zai-xian-zuo-fa-shu-shang-bei-zeng-lca-b-lzjq/">参考题解</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">distanceLimitedPathsExist</span><span class="hljs-params">(n <span class="hljs-type">int</span>, e [][]<span class="hljs-type">int</span>, qs [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">bool</span> &#123;<br>sort.Slice(e, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> e[i][<span class="hljs-number">2</span>] &lt; e[j][<span class="hljs-number">2</span>] &#125;)<br>id := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(qs))<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> qs &#123;<br>id[i] = i<br>&#125;<br>sort.Slice(id, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> qs[id[i]][<span class="hljs-number">2</span>] &lt; qs[id[j]][<span class="hljs-number">2</span>] &#125;)<br>fa := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> fa &#123;<br>fa[i] = i<br>&#125;<br><span class="hljs-keyword">var</span> get <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br>get = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> fa[x] == x &#123;<br><span class="hljs-keyword">return</span> x<br>&#125;<br>fa[x] = get(fa[x])<br><span class="hljs-keyword">return</span> fa[x]<br>&#125;<br>ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(qs))<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(qs); j++ &#123;<br>q := qs[id[j]]<br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(e) &amp;&amp; e[i][<span class="hljs-number">2</span>] &lt; q[<span class="hljs-number">2</span>] &#123;<br>fa[get(e[i][<span class="hljs-number">0</span>])] = get(e[i][<span class="hljs-number">1</span>])<br>i++<br>&#125;<br>ans[id[j]] = get(q[<span class="hljs-number">0</span>]) == get(q[<span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>并查集按照条件分步处理连通性在 Leetcode 上并不是第一次遇到了，往往思路都需要转换一下。能想到思路一般很顺，想不到的话题目就有难度了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>离线算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC.1691堆叠长方体的最大高度</title>
    <link href="/2022/12/13/LC-1691%E5%A0%86%E5%8F%A0%E9%95%BF%E6%96%B9%E4%BD%93%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/"/>
    <url>/2022/12/13/LC-1691%E5%A0%86%E5%8F%A0%E9%95%BF%E6%96%B9%E4%BD%93%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/description/">题目链接</a> | <a href="https://leetcode.cn/contest/weekly-contest-219">第 219 场单周赛</a> | <a href="https://leetcode.cn/contest/weekly-contest-219/problems/maximum-height-by-stacking-cuboids/">Q4</a> | 难度:2172</p>          </div><details><summary>题目描述</summary><p>给你 <code>n</code> 个长方体 <code>cuboids</code> ，其中第 <code>i</code> 个长方体的长宽高表示为 <code>cuboids[i] = [width<sub>i</sub>, length<sub>i</sub>, height<sub>i</sub>]</code>（<strong>下标从 0 开始</strong>）。请你从 <code>cuboids</code> 选出一个 <strong>子集</strong> ，并将它们堆叠起来。</p><p>如果 <code>width<sub>i</sub> <= width<sub>j</sub></code> 且 <code>length<sub>i</sub> <= length<sub>j</sub></code> 且 <code>height<sub>i</sub> <= height<sub>j</sub></code> ，你就可以将长方体 <code>i</code> 堆叠在长方体 <code>j</code> 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。</p><p>返回 <strong>堆叠长方体</strong> <code>cuboids</code> 可以得到的 <strong>最大高度</strong> 。</p><p> </p><p><strong>示例 1：</strong></p><p><strong><img alt="" src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20221213184020.png" style="width: 420px; height: 299px;" /></strong></p><pre><strong>输入：</strong>cuboids = [[50,45,20],[95,37,53],[45,23,12]]<strong>输出：</strong>190<strong>解释：</strong>第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。总高度是 95 + 50 + 45 = 190 。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>cuboids = [[38,25,45],[76,35,3]]<strong>输出：</strong>76<strong>解释：</strong>无法将任何长方体放在另一个上面。选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]<strong>输出：</strong>102<strong>解释：</strong>重新排列长方体后，可以看到所有长方体的尺寸都相同。你可以把 11x7 的一面朝下，这样它们的高度就是 17 。堆叠长方体的最大高度为 6 * 17 = 102 。</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>n == cuboids.length</code></li>    <li><code>1 <= n <= 100</code></li>    <li><code>1 <= width<sub>i</sub>, length<sub>i</sub>, height<sub>i</sub> <= 100</code></li></ul></details><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h2 id="这道题注意是三维都是要满足前者比后者小的，也就是说，长方体可以嵌套，把嵌套的长方体按照高叠起来，求最长的高度。1-三个维度都可以嵌套，那么哪个作为高呢？1-在转移的时候，需要排序是肯定的，那如何制定排序规则才可以使动态方程转移的时候能够按照合适的顺序执行呢？-如何定义合适？"><a href="#这道题注意是三维都是要满足前者比后者小的，也就是说，长方体可以嵌套，把嵌套的长方体按照高叠起来，求最长的高度。1-三个维度都可以嵌套，那么哪个作为高呢？1-在转移的时候，需要排序是肯定的，那如何制定排序规则才可以使动态方程转移的时候能够按照合适的顺序执行呢？-如何定义合适？" class="headerlink" title="这道题注意是三维都是要满足前者比后者小的，也就是说，长方体可以嵌套，把嵌套的长方体按照高叠起来，求最长的高度。1. 三个维度都可以嵌套，那么哪个作为高呢？1. 在转移的时候，需要排序是肯定的，那如何制定排序规则才可以使动态方程转移的时候能够按照合适的顺序执行呢？ 如何定义合适？"></a>这道题注意是三维都是要满足前者比后者小的，也就是说，长方体可以嵌套，把嵌套的长方体按照高叠起来，求最长的高度。<br><div class="note note-primary">            <p>这道题 明确动态转移方程后就很直观了，但是需要先确定贪心过程。</p>          </div><br>1. 三个维度都可以嵌套，那么哪个作为高呢？<br>1. 在转移的时候，需要排序是肯定的，那如何制定排序规则才可以使动态方程转移的时候能够按照<strong>合适</strong>的顺序执行呢？ 如何定义合适？</h2><h3 id="贪心排序"><a href="#贪心排序" class="headerlink" title="贪心排序"></a>贪心排序</h3><ol><li>如果一个盒子 <code>y</code> 可以嵌套另一个盒子 <code>x</code>, 那么，我们肯定以最大的值作为 <code>y</code> 和 <code>x</code> 的高。</li><li>比较 <code>y</code> 可以嵌套 <code>x</code>， 我们可以把其三维排序，小对小，中对中，大对大进行比较。</li><li>如何指定排序规则，需要满足一个准则，在遍历 <code>j</code> 的时候，没有遍历过的元素， 一定<strong>不可以</strong>去嵌套<code>j</code>，也就是说至少有一个维度比 <code>j</code> 大。</li></ol><div class="note note-secondary">            <p>按照这种排序规则，很容易指定排序规则，设排序后三维为 <code>a,b,c</code>，那就是先按最小的元素 <code>a</code> 排，如果 <code>a</code> 相等在按 <code>b</code> 排， 在按 <code>c</code> 排。同时把 <code>c</code> 最为高。</p>          </div><details>  <summary>更简单的排序</summary><p>其实可以用三维和作为键进行排序，可以思考一下为什么</p></details><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>$f[i]$ : 表示第 <code>i</code> 个盒子可以达到的最大高度。<br>$$<br>f[j] &#x3D; max_{i&#x3D;0}^{j-1}{f[i]~~~if~~check(i)} + height_j<br>$$</p><blockquote><p>意思就是从前面找到最大的一个合适的 <code>i</code>, 在加上当前的那个盒子。<code>check</code>函数就是检查 <code>i</code> 的三维比 <code>j</code> 的三维都要小。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 按照 三个维度和 进行排序</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxHeight</span><span class="hljs-params">(c [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(c)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c &#123;<br>sort.Ints(c[i])<br>&#125;<br>sort.Slice(c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> c[i][<span class="hljs-number">0</span>]+c[i][<span class="hljs-number">1</span>]+c[i][<span class="hljs-number">2</span>] &lt; c[j][<span class="hljs-number">0</span>]+c[j][<span class="hljs-number">1</span>]+c[j][<span class="hljs-number">2</span>]<br>&#125;)<br>f := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br><span class="hljs-keyword">if</span> c[j][<span class="hljs-number">0</span>] &lt;= c[i][<span class="hljs-number">0</span>] &amp;&amp; c[j][<span class="hljs-number">1</span>] &lt;= c[i][<span class="hljs-number">1</span>] &amp;&amp; c[j][<span class="hljs-number">2</span>] &lt;= c[i][<span class="hljs-number">2</span>] &#123;<br>f[i] = max(f[i], f[j])<br>&#125;<br>&#125;<br>f[i] += c[i][<span class="hljs-number">2</span>]<br>&#125;<br><span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> f &#123;<br>ans = max(ans, v)<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &lt; b &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 按照一般排序规则</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxHeight</span><span class="hljs-params">(c [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(c)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c &#123;<br>sort.Ints(c[i])<br>&#125;<br>sort.Slice(c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> c[i][<span class="hljs-number">0</span>] &lt; c[j][<span class="hljs-number">0</span>] || (c[i][<span class="hljs-number">0</span>] == c[j][<span class="hljs-number">0</span>] &amp;&amp; c[i][<span class="hljs-number">1</span>] &lt; c[j][<span class="hljs-number">1</span>]) || c[i][<span class="hljs-number">0</span>] == c[j][<span class="hljs-number">0</span>] &amp;&amp; c[i][<span class="hljs-number">1</span>] == c[j][<span class="hljs-number">1</span>] &amp;&amp; c[i][<span class="hljs-number">2</span>] &lt; c[j][<span class="hljs-number">2</span>]<br>&#125;)<br>f := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br><span class="hljs-keyword">if</span> c[j][<span class="hljs-number">1</span>] &lt;= c[i][<span class="hljs-number">1</span>] &amp;&amp; c[j][<span class="hljs-number">2</span>] &lt;= c[i][<span class="hljs-number">2</span>] &#123;<br>f[i] = max(f[i], f[j])<br>&#125;<br>&#125;<br>f[i] += c[i][<span class="hljs-number">2</span>]<br>&#125;<br><span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> f &#123;<br>ans = max(ans, v)<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &lt; b &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note note-info">            <p>动态规划多多总结吧🍸</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用xclip与系统剪贴板进行交互</title>
    <link href="/2022/12/10/%E4%BD%BF%E7%94%A8xclip%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/"/>
    <url>/2022/12/10/%E4%BD%BF%E7%94%A8xclip%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/</url>
    
    <content type="html"><![CDATA[<h2 id="xclip操作"><a href="#xclip操作" class="headerlink" title="xclip操作"></a>xclip操作</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs txt">Usage: xclip [OPTION] [FILE]...<br>Access an X server selection for reading or writing.<br><br>  -i, -in          read text into X selection from standard input or files<br>                   (default)<br>  -o, -out         prints the selection to standard out (generally for<br>                   piping to a file or program)<br>  -l, -loops       number of selection requests to wait for before exiting<br>  -d, -display     X display to connect to (eg localhost:0&quot;)<br>  -h, -help        usage information<br>      -selection   selection to access (&quot;primary&quot;, &quot;secondary&quot;, &quot;clipboard&quot; or &quot;buffer-c<br>ut&quot;)<br>      -noutf8      don&#x27;t treat text as utf-8, use old unicode<br>      -target      use the given target atom<br>      -rmlastnl    remove the last newline character if present<br>      -version     version information<br>      -silent      errors only, run in background (default)<br>      -quiet       run in foreground, show what&#x27;s happening<br>      -verbose     running commentary<br><br>Report bugs to &lt;astrand@lysator.liu.se&gt;<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">参数       | 作用<br>-----------------------------<br>-i         | 读入到剪贴板<br>-o         | 从剪贴板写出<br>-selection | 选择剪贴板<br>-target    | 指定读入/读出的格式<br></code></pre></td></tr></table></figure><h2 id="xclip复制文本文件"><a href="#xclip复制文本文件" class="headerlink" title="xclip复制文本文件"></a>xclip复制文本文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span> | xclip<br></code></pre></td></tr></table></figure><p>以上命令并不是使用 系统 <strong>剪贴板</strong>, 如果需要像使用 <code>Cltr-v</code> 那样复制, 需要指定使用系统剪贴板, 通过参数 <span class="label label-primary">-selection -clipbord</span>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span> | xclip -selection -clipbord<br></code></pre></td></tr></table></figure><h2 id="xclip复制图片文件"><a href="#xclip复制图片文件" class="headerlink" title="xclip复制图片文件"></a>xclip复制图片文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 复制 1.png 内容到系统剪贴板 </span><br>xclip -selection -clipbord &lt; 1.png<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>注意以下操作并不能成功</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xclip -selection -clipbord -o &gt; 2.png<br></code></pre></td></tr></table></figure><blockquote><p>因为, 没有指定文件格式, <code>xclip</code> 还是像复制文本文件一样复制其内容, 不是标准 <code>png</code> 格式.</p></blockquote><div class="note note-success">            <p>因此需要通过 <code>-t</code> 指定为图片格式</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xclip -selection -clipbord -t image/png -o &gt; 2.png<br></code></pre></td></tr></table></figure><p>也可以在读入的时候指定文件格式, 这样会更友好:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 复制 1.png 内容到系统剪贴板 </span><br>xclip -selection -clipbord -t image/png -i 1.png<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC.1780判断一个数字是否可以表示成三的幂的和</title>
    <link href="/2022/12/09/LC-1780%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E6%88%90%E4%B8%89%E7%9A%84%E5%B9%82%E7%9A%84%E5%92%8C/"/>
    <url>/2022/12/09/LC-1780%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E6%88%90%E4%B8%89%E7%9A%84%E5%B9%82%E7%9A%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/description/">题目链接</a> | <a href="https://leetcode.cn/contest/biweekly-contest-47">第 47 场双周赛</a> | <a href="https://leetcode.cn/contest/biweekly-contest-47/problems/check-if-number-is-a-sum-of-powers-of-three/">Q2</a> | 难度:1506</p>          </div><details><summary>题目描述</summary><p>给你一个整数 <code>n</code> ，如果你可以将 <code>n</code> 表示成若干个不同的三的幂之和，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p><p>对于一个整数 <code>y</code> ，如果存在整数 <code>x</code> 满足 <code>y == 3<sup>x</sup></code> ，我们称这个整数 <code>y</code> 是三的幂。</p><p> </p><p><strong>示例 1：</strong></p><pre><b>输入：</b>n = 12<b>输出：</b>true<b>解释：</b>12 = 3<sup>1</sup> + 3<sup>2</sup></pre><p><strong>示例 2：</strong></p><pre><b>输入：</b>n = 91<b>输出：</b>true<b>解释：</b>91 = 3<sup>0</sup> + 3<sup>2</sup> + 3<sup>4</sup></pre><p><strong>示例 3：</strong></p><pre><b>输入：</b>n = 21<b>输出：</b>false</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= n &lt;= 10<sup>7</sup></code></li></ul></details><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="回溯暴力解-求子集"><a href="#回溯暴力解-求子集" class="headerlink" title="回溯暴力解(求子集)"></a>回溯暴力解(求子集)</h3><p>这道题的 <code>n</code> 还是太小了, 可以使用回溯暴力解</p><details>  <summary>回溯暴力解</summary><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkPowersOfThree</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>p := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">16</span>)<br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(p); i++ &#123;<br>p[i] = p[i<span class="hljs-number">-1</span>] * <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, sum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br>dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, sum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">15</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> sum &gt; n &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> sum == n &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> dfs(i+<span class="hljs-number">1</span>, sum+p[i]) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> dfs(i+<span class="hljs-number">1</span>, sum)<br>&#125;<br><span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="正规解法-数学"><a href="#正规解法-数学" class="headerlink" title="正规解法(数学)"></a>正规解法(数学)</h3><p>$n&#x3D;\sum{p*3^a}$, 其中 <code>p</code> 只能是 <code>0/1</code>, <code>a</code> 就是幂次.\</p><blockquote><p>所以, <code>p</code> 只能是<code>0/1</code></p></blockquote><ol><li>把 <code>n</code> 用 <code>3</code> 进制表示</li><li>查看是否含有<code>2</code>, 有则<code>false</code>, 无则<code>true</code></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// n 转 3 进制</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>a := []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;<br>a = <span class="hljs-built_in">append</span>(a, n%<span class="hljs-number">3</span>)<br>n /= <span class="hljs-number">3</span><br>&#125;<br>    <span class="hljs-comment">// 这道题只需检验有没有2, 没有必要反转</span><br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>a[i], a[j] = a[j], a[i]<br>&#125;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkPowersOfThree</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>a := get(n)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> v == <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进制转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC.1775通过最少操作次数使数组的和相等</title>
    <link href="/2022/12/07/LC-1775%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/"/>
    <url>/2022/12/07/LC-1775%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/description/">题目链接</a> | <a href="https://leetcode.cn/contest/weekly-contest-230">第 230 场单周赛</a> | <a href="https://leetcode.cn/contest/weekly-contest-230/problems/equal-sum-arrays-with-minimum-number-of-operations/">Q3</a> | 难度:1850</p>          </div><details><summary>题目描述</summary><p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 <code>1</code> 和 <code>6</code>）。</p><p>每次操作中，你可以选择 <strong>任意</strong> 数组中的任意一个整数，将它变成 <code>1</code> 到 <code>6</code> 之间 <strong>任意</strong> 的值（包含 <code>1</code> 和 <code><span style="">6</span></code>）。</p><p>请你返回使 <code>nums1</code> 中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 <code>-1</code> 。</p><p> </p><p><strong>示例 1：</strong></p><pre><b>输入：</b>nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]<b>输出：</b>3<b>解释：</b>你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [<strong>6</strong>,1,2,2,2,2] 。- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,<strong>1</strong>], nums2 = [6,1,2,2,2,2] 。- 将 nums1[2] 变为 2 。 nums1 = [1,2,<strong>2</strong>,4,5,1], nums2 = [6,1,2,2,2,2] 。</pre><p><strong>示例 2：</strong></p><pre><b>输入：</b>nums1 = [1,1,1,1,1,1,1], nums2 = [6]<b>输出：</b>-1<b>解释：</b>没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。</pre><p><strong>示例 3：</strong></p><pre><b>输入：</b>nums1 = [6,6], nums2 = [1]<b>输出：</b>3<b>解释：</b>你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。- 将 nums1[0] 变为 2 。 nums1 = [<strong>2</strong>,6], nums2 = [1] 。- 将 nums1[1] 变为 2 。 nums1 = [2,<strong>2</strong>], nums2 = [1] 。- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [<strong>4</strong>] 。</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>    <li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li></ul></details><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><div class="note note-primary">            <p>思考: 使用和不使用 1-6 这个条件对思路有什么影响呢?</p>          </div><p>这道题是一道贪心的题目, 关键点在于能够想出合适的贪心策略:</p><ol><li>考虑一下什么情况下没有解?</li><li>我们把和大的一方记为 A, 其长度为 $len_A$, 小的一方记为 B, 其长度为 $len_B$. </li><li>如果 $max(len_A,len_B) * 6 &lt; min(len_A, len_B)$, 那么肯定是没有解的, 因为在把长度长的数组和变为最大, 长度小的数组和变为最小的情况下, 长度大的一方还比长度小的一方小, 那肯定没有办法在调整了. 已经是极限了. 没有答案. 除此意外都是有解的.</li><li>把 A 变小, 实际上就是把 B 变大, 我们可以固定 A 不动, 去尽可能变大 B. 这样的次数一定是最小的.</li><li>数组 A 的元素要尽可能变为 1, 数组 B 的元素要尽可能变为 6.</li><li>把 A 和 B 所能改动的数值记录到一个数组下, 从大到小(从 5 到 1)迭代该数组, 找到答案.</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getCnt</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> (s <span class="hljs-type">int</span>, c []<span class="hljs-type">int</span>) &#123;<br>c = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">7</span>)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>s += v<br>c[v]++<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solve</span><span class="hljs-params">(ma, mi []<span class="hljs-type">int</span>, a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>m := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">6</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">6</span>; i++ &#123;<br>m[<span class="hljs-number">6</span>-i] += mi[i]<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">6</span>; i &gt; <span class="hljs-number">1</span>; i-- &#123;<br>m[i<span class="hljs-number">-1</span>] += ma[i]<br>&#125;<br><span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">5</span>; i &gt;= <span class="hljs-number">1</span>; i-- &#123;<br><span class="hljs-keyword">if</span> b+i*m[i] &gt;= a &#123;<br>ans += (a - b + i - <span class="hljs-number">1</span>) / i<br><span class="hljs-keyword">break</span><br>&#125;<br>ans += m[i]<br>b += i * m[i]<br>&#125;<br><br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>l1, l2 := <span class="hljs-built_in">len</span>(nums1), <span class="hljs-built_in">len</span>(nums2)<br><span class="hljs-keyword">if</span> max(l1, l2) &gt; min(l1, l2)*<span class="hljs-number">6</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>sa, a := getCnt(nums1)<br>sb, b := getCnt(nums2)<br><span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> sa &lt; sb &#123;<br>ans = solve(b, a, sb, sa)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ans = solve(a, b, sa, sb)<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &lt; b &#123;<br><span class="hljs-keyword">return</span> b<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> b<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编码的时候要快速求得正确个数, 如下面的代码, 这要求熟悉编程语言的除法取整, 在这里总结一下.</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">if b+i*m[i] &gt;= a &#123;<br><span class="hljs-addition">+ans += (a - b + i - 1) / i</span><br>break<br>&#125;<br></code></pre></td></tr></table></figure><p>对于两个正整数:</p><ol><li>$ax\le b$ 可以取得 -&gt; $x \le \lfloor b&#x2F;a \rfloor$. </li><li>$ax&lt; b$ 可以取得 -&gt; $x &lt; \lceil b&#x2F;a \rceil$.</li><li>$ax\ge b$ 可以取得 -&gt; $x \ge \lceil b&#x2F;a \rceil$.</li><li>$ax&gt; b$ 可以取得 -&gt; $x &gt; \lfloor b&#x2F;a \rfloor$.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一茶:C-ABS Permutation</title>
    <link href="/2022/12/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%8C%B6-C-ABS-Permutation/"/>
    <url>/2022/12/07/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%8C%B6-C-ABS-Permutation/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>题目链接: <a href="https://atcoder.jp/contests/arc140/tasks/arc140_c">Atcoder</a> | 难度: 1597</p>          </div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入 n 和 x (x≤n≤2e5)。<br>你需要构造一个 1~n 的排列 p，其中第一项为 x。<br>p 可以生成一个长为 n-1 的数组 a，使得 a[i]=abs(p[i]-p[i+1])。<br>通过构造合适的 p，最大化 a 的 LIS（最长严格递增子序列）的长度。<br>输出 p。<br></code></pre></td></tr></table></figure><p><strong>输入</strong>:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">N X<br></code></pre></td></tr></table></figure><p><strong>输出</strong>:<br>P1 P2 … PN<br><strong>样例</strong>:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">Input:<br>3 2<br>Output:<br>2 1 3<br><br>Input:<br>3 1<br>Output:<br>1 2 3<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><a href="https://atcoder.jp/contests/arc140/editorial/3970">官方题解</a>  点击图片查看大图<br><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20221207165159.png"></p><h2 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码<a href="https://atcoder.jp/contests/arc140/submissions/37074852">Submissions</a></p><details><summary>代码</summary><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">even</span>(n: <span class="hljs-type">i64</span>, x: <span class="hljs-type">i64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i64</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = n / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> a, <span class="hljs-keyword">mut</span> b, <span class="hljs-keyword">mut</span> d) = <span class="hljs-keyword">match</span> x.<span class="hljs-title function_ invoke__">cmp</span>(&amp;m) &#123;<br>        Ordering::Less =&gt; (m, m + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>),<br>        Ordering::Equal =&gt; (m - <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>),<br>        Ordering::Greater =&gt; (m, m + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>),<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ans</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(n <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span> - <span class="hljs-number">1</span>);<br>    ans.<span class="hljs-title function_ invoke__">push</span>(x);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n / <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">if</span> a == x &#123;<br>            a -= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> b == x &#123;<br>            b += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> d &#123;<br>            <span class="hljs-keyword">if</span> a &gt;= <span class="hljs-number">1</span> &#123;<br>                ans.<span class="hljs-title function_ invoke__">push</span>(a);<br>                a -= <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> b &lt;= n &#123;<br>                ans.<span class="hljs-title function_ invoke__">push</span>(b);<br>                b += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> b &lt;= n &#123;<br>                ans.<span class="hljs-title function_ invoke__">push</span>(b);<br>                b += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> a &gt;= <span class="hljs-number">1</span> &#123;<br>                ans.<span class="hljs-title function_ invoke__">push</span>(a);<br>                a -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    ans<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">odd</span>(n: <span class="hljs-type">i64</span>, x: <span class="hljs-type">i64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i64</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> a, <span class="hljs-keyword">mut</span> b) = <span class="hljs-keyword">match</span> x.<span class="hljs-title function_ invoke__">cmp</span>(&amp;m) &#123;<br>        Ordering::Less =&gt; (m, m + <span class="hljs-number">1</span>),<br>        Ordering::Equal =&gt; (m - <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>),<br>        Ordering::Greater =&gt; (m - <span class="hljs-number">1</span>, m),<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ans</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(n <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span> - <span class="hljs-number">1</span>);<br>    ans.<span class="hljs-title function_ invoke__">push</span>(x);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n / <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">if</span> a == x &#123;<br>            a -= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> b == x &#123;<br>            b += <span class="hljs-number">1</span>;<br>        &#125;<br>        ans.<span class="hljs-title function_ invoke__">push</span>(a);<br>        ans.<span class="hljs-title function_ invoke__">push</span>(b);<br>        a -= <span class="hljs-number">1</span>;<br>        b += <span class="hljs-number">1</span>;<br>    &#125;<br>    ans<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scan</span> = Scanner::<span class="hljs-title function_ invoke__">default</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">out</span> = &amp;<span class="hljs-keyword">mut</span> BufWriter::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">stdout</span>());<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = scan.next::&lt;<span class="hljs-type">i64</span>&gt;();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = scan.next::&lt;<span class="hljs-type">i64</span>&gt;();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ans</span> = <span class="hljs-keyword">if</span> n &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span> &#123; <span class="hljs-title function_ invoke__">odd</span>(n, x) &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-title function_ invoke__">even</span>(n, x) &#125;;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> ans &#123;<br>        <span class="hljs-built_in">write!</span>(out, <span class="hljs-string">&quot;&#123;&#125; &quot;</span>, v);<br>    &#125;<br>    <span class="hljs-comment">// println!(&quot;&#123;:?&#125;&quot;, ans);</span><br>    <span class="hljs-comment">// writeln!(out, &quot;&#123;&#125;&quot;, &quot;done&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure></details>]]></content>
    
    
    <categories>
      
      <category>每日一茶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你值得拥有更好的终端模拟器: Alacritty配置</title>
    <link href="/2022/12/06/%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%BB%88%E7%AB%AF-Alacritty%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/12/06/%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%BB%88%E7%AB%AF-Alacritty%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>Alacritty <a href="https://github.com/alacritty/alacritty">GitHub地址</a></p>          </div><h2 id="为什么需要一款足够Modern的终端模拟器呢"><a href="#为什么需要一款足够Modern的终端模拟器呢" class="headerlink" title="为什么需要一款足够Modern的终端模拟器呢?"></a>为什么需要一款足够Modern的终端模拟器呢?</h2><blockquote><p>因为Alacritty足够快(GPU 加速), 足够小(Rust 编写), 足够好看(主题丰富). 当然也有一些使用的功能.</p></blockquote><p>终端模拟器(Terminal)并不是对标的 Bash, Zsh, Fish 等终端(Shell), Terminal 是 Shell 的一个容器, 供用户在这个容器下可以使用 Bash&#x2F;Zsh&#x2F;Fish, 这个容器在图形界面的操作系统下尤其重要, 因为这意味着用户不必要切换到 TTY 模式才可以敲击命令行. <br>Alacritty 和 Gnome-terminal, iTerm2, Kitty 等等同属于终端模拟器.</p><p>对于普通的用户, 尤其是 Windows 用户, 对终端的需求可能并不是很高, 大部分开发工作都是集成的. 一款 IDE 解决所有问题. 但是对于 Unix 用户来说, 终端是计算机的灵魂, 尤其是使用 Vim 作为开发工具的程序员, 终端更是不可或缺的. 以 Ubuntu 来说, 内置的 Gnome-terminal 基本可以满足所有的需求, 但是, 在大量使用情况下, 谁又拒绝一款更好的工具呢, 并且还是用 <strong>Rust</strong> 编写的, 主观来讲, 对 <strong>Go</strong> 和 <strong>Rust</strong> 写的程序总有一种天然的好感.</p><p class="note note-success">工欲善其事，必先利其器</p><p><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20221206231704.png" alt="目前配置"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="note note-primary">            <p><a href="https://github.com/alacritty/alacritty/blob/master/INSTALL.md">官方安装文档</a></p>          </div><p>如果是 Windows 和 MacOS, 那么可以直接通过安装包安装部署. 如果是 Linux 用户, 也可以在上述官方文档中找到对应的 Linux 发行版进行安装.</p><blockquote><p>建议通过 Rust 手动安装, 以后也方便更新.</p></blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Alacritty 通过一个<code>alacritty.yml</code>配置文件进行配置. 该文件默认是没有的, 需要自己生成.<br>文件目录位置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// Linux: 以下4个任意一个<br><span class="hljs-variable">$XDG_CONFIG_HOME</span>/alacritty/alacritty.yml<br><span class="hljs-variable">$XDG_CONFIG_HOME</span>/alacritty.yml<br><span class="hljs-variable">$HOME</span>/.config/alacritty/alacritty.yml<br><span class="hljs-variable">$HOME</span>/.alacritty.yml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// Windows: windows用户可能比较了解 APPDATA 的位置<br>%APPDATA%\alacritty\alacritty.yml<br></code></pre></td></tr></table></figure><p>官方项目下有个文件<a href="https://github.com/alacritty/alacritty/blob/master/alacritty.yml">alacritty.yml</a>, 里面有对每个配置详细的说明, 可以很大程度自定义.</p><h3 id="融合-Zsh-Bash-Fish-终端"><a href="#融合-Zsh-Bash-Fish-终端" class="headerlink" title="融合 Zsh&#x2F;Bash&#x2F;Fish 终端"></a>融合 Zsh&#x2F;Bash&#x2F;Fish 终端</h3><p>只需要让使用的终端找到alacritty的配置就好了, 配置文件在<a href="https://github.com/alacritty/alacritty/tree/master/extra/completions">官方文档</a>中找到, </p><p>以Bash为例, 其中 <code>pwd</code> 是<code>alacritty.bash</code>所在目录, 建议存在一个固定的配置目录下.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;source <span class="hljs-subst">$(pwd)</span>/alacritty.bash&quot;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><h3 id="颜色主题"><a href="#颜色主题" class="headerlink" title="颜色主题"></a>颜色主题</h3><p>通过该配置文件是很难测试出一个喜欢的主题颜色的, 可以使用别人写好的一款工具, 但是需要 Node.js 环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g alacritty-themes<br></code></pre></td></tr></table></figure><blockquote><p>执行完后可以直接运行该程序, 就可以直接选择了, 该程序的作用就是在 <code>alacritty.yml</code> 文件里写一些颜色方案. 所以, 如果不想安装该环境, 可以在网上找一找自己喜欢的配色.</p></blockquote><details>  <summary>我的颜色方案</summary><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">colors:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Lumifoo</span><br>  <span class="hljs-attr">author:</span> <span class="hljs-string">Gutterslob</span><br>  <span class="hljs-attr">primary:</span><br>    <span class="hljs-attr">background:</span> <span class="hljs-string">&quot;#1e2021&quot;</span><br>    <span class="hljs-attr">foreground:</span> <span class="hljs-string">&quot;#888a8c&quot;</span><br>  <span class="hljs-attr">cursor:</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">&quot;#1e2021&quot;</span><br>    <span class="hljs-attr">cursor:</span> <span class="hljs-string">&quot;#888a8c&quot;</span><br>  <span class="hljs-attr">normal:</span><br>    <span class="hljs-attr">black:</span> <span class="hljs-string">&quot;#515151&quot;</span><br>    <span class="hljs-attr">red:</span> <span class="hljs-string">&quot;#bf6382&quot;</span><br>    <span class="hljs-attr">green:</span> <span class="hljs-string">&quot;#65a446&quot;</span><br>    <span class="hljs-attr">yellow:</span> <span class="hljs-string">&quot;#ad8a43&quot;</span><br>    <span class="hljs-attr">blue:</span> <span class="hljs-string">&quot;#6b85c2&quot;</span><br>    <span class="hljs-attr">magenta:</span> <span class="hljs-string">&quot;#9e6bb8&quot;</span><br>    <span class="hljs-attr">cyan:</span> <span class="hljs-string">&quot;#5c9d88&quot;</span><br>    <span class="hljs-attr">white:</span> <span class="hljs-string">&quot;#919191&quot;</span><br>  <span class="hljs-attr">bright:</span><br>    <span class="hljs-attr">black:</span> <span class="hljs-string">&quot;#707172&quot;</span><br>    <span class="hljs-attr">red:</span> <span class="hljs-string">&quot;#eaaec2&quot;</span><br>    <span class="hljs-attr">green:</span> <span class="hljs-string">&quot;#aed49b&quot;</span><br>    <span class="hljs-attr">yellow:</span> <span class="hljs-string">&quot;#d4c3a0&quot;</span><br>    <span class="hljs-attr">blue:</span> <span class="hljs-string">&quot;#afc4e9&quot;</span><br>    <span class="hljs-attr">magenta:</span> <span class="hljs-string">&quot;#d2b1e2&quot;</span><br>    <span class="hljs-attr">cyan:</span> <span class="hljs-string">&quot;#a4d0c1&quot;</span><br>    <span class="hljs-attr">white:</span> <span class="hljs-string">&quot;#d0d0d0&quot;</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">Gutterslob</span> <span class="hljs-bullet">-</span> <span class="hljs-string">lumifoo</span><br></code></pre></td></tr></table></figure></details><h2 id="设置Alacritty为首选终端"><a href="#设置Alacritty为首选终端" class="headerlink" title="设置Alacritty为首选终端"></a>设置Alacritty为首选终端</h2><h3 id="配置Ctrl-Alt-t"><a href="#配置Ctrl-Alt-t" class="headerlink" title="配置Ctrl-Alt-t"></a>配置<code>Ctrl-Alt-t</code></h3><p>如果你对Ubuntu比较熟悉, 应该是到<code>Ctrl-Alt-t</code>是可以打开自带终端的, 那么如何设置当我们执行<code>Ctrl-Alt-t</code>时打开的是Alacritty.<br>需要执行以下命令: <code>/usr/bin/alacritty</code> 根据自己的alacritty位置做修改.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-alternatives --install /usr/bin/x-terminal-emulator x-terminal-emulator /usr/bin/alacritty 50<br></code></pre></td></tr></table></figure><p>查看当前的终端选项的优先级:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-alternatives --config x-terminal-emulator<br></code></pre></td></tr></table></figure><p>如果想要删除 alacritty 终端选项, 可以执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-alternatives --remove <span class="hljs-string">&quot;x-terminal-emulator&quot;</span> <span class="hljs-string">&quot;/usr/bin/alacritty&quot;</span><br></code></pre></td></tr></table></figure><h3 id="配置Open-in-Terminal菜单"><a href="#配置Open-in-Terminal菜单" class="headerlink" title="配置Open in Terminal菜单"></a>配置<code>Open in Terminal</code>菜单</h3><div class="note note-danger">            <p>这个需要修改 Ubuntu Gnome-shell 内部配置, 如果真的有需要, 可以参考这个项目<a href="https://github.com/Stunkymonkey/nautilus-open-any-terminal">nautilus-open-any-terminal | 点击跳转</a></p>          </div><blockquote><p>其实, <code>Ctrl-Alt-t</code> 也可以通过上述项目进行修改, 因为是通过<span class="label label-danger">dconf-editor</span> 进行修改的.</p></blockquote><p>最终效果:<br><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20221206235115.png"></p><div class="note note-success">            <p>这样就可以通过 <code>Ctrl-Alt-t</code> 和 <code>Open in Terminal</code> 启动Alacritty了.</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>善其事,利其器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一茶:C-Sequence</title>
    <link href="/2022/12/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%8C%B6-C-Sequence/"/>
    <url>/2022/12/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%8C%B6-C-Sequence/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>题目链接: <a href="https://atcoder.jp/contests/abc059/tasks/arc072_a">Atcoder</a> | <a href="https://atcoder.jp/contests/abc059/submissions/37050266">灵茶代码</a></p>          </div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入 n (2≤n≤1e5) 和一个长为 n 的数组 a (-1e9≤a[i]≤1e9)。<br>每次操作你可以把一个 a[i] 加一或减一。<br>如果要让 a 的所有相邻前缀和的乘积都小于 0，至少需要操作多少次？<br></code></pre></td></tr></table></figure><p><strong>输入</strong>:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">n<br>a1, a2, ... , an<br></code></pre></td></tr></table></figure><p><strong>输出</strong>:</p><p>最小操作数</p><details>  <summary>样例</summary><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs txt">Sample Input 1 <br>4<br>1 -3 1 0<br>Sample Output 1 <br>4<br><br>Sample Input 2 <br>5<br>3 -6 4 -5 7<br>Sample Output 2 <br>0<br><br>Sample Input 2 <br>5<br>3 -6 4 -5 7<br>Sample Output 2 <br>0<br></code></pre></td></tr></table></figure></details><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote><p>根据第一个选择是正&#x2F;负, 就决定了后续的顺序, 因此只有两种可能.</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">提示 1：前缀和的符号要么是 -+-+... 要么是 +-+-...<br><br>提示 2：如果一个前缀和的符号已经和期望的符号相同，那么就无需修改（因为修改后面的可以达到同样的效果）<br><br>因此，枚举前缀和要变成提示 1 中的哪一种，<br>然后从左到右遍历前缀和，如果符号和期望的不同，就直接改成 1 或者 -1。<br><br>代码实现时有一些技巧，可以看看。<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details><summary>代码</summary><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scan</span> = Scanner::<span class="hljs-title function_ invoke__">default</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">out</span> = &amp;<span class="hljs-keyword">mut</span> BufWriter::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">stdout</span>());<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = scan.next::&lt;<span class="hljs-type">usize</span>&gt;();<br>    <span class="hljs-comment">// let a = (0..n).map(|_| scan.next()).collect::&lt;Vec&lt;i64&gt;&gt;();</span><br>    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> a, <span class="hljs-keyword">mut</span> b) = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> x, <span class="hljs-keyword">mut</span> y) = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = scan.next::&lt;<span class="hljs-type">i64</span>&gt;();<br>        a += c;<br>        b += c;<br>        <span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> a &lt;= <span class="hljs-number">0</span> &#123;<br>                x += -a + <span class="hljs-number">1</span>;<br>                a = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> b &gt;= <span class="hljs-number">0</span> &#123;<br>                y += b + <span class="hljs-number">1</span>;<br>                b = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> a &gt;= <span class="hljs-number">0</span> &#123;<br>                x += a + <span class="hljs-number">1</span>;<br>                a = -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> b &lt;= <span class="hljs-number">0</span> &#123;<br>                y += -b + <span class="hljs-number">1</span>;<br>                b = <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ans</span> = <span class="hljs-type">i64</span>::<span class="hljs-title function_ invoke__">min</span>(x, y);<br><br>    <span class="hljs-built_in">writeln!</span>(out, <span class="hljs-string">&quot;&#123;&#125;&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 灵茶代码</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br>. <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">// https://space.bilibili.com/206214</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>in := bufio.NewReader(os.Stdin)<br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>Fscan(in, &amp;n)<br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> a &#123;<br>Fscan(in, &amp;a[i])<br>&#125;<br>f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(to <span class="hljs-type">int</span>)</span></span> (res <span class="hljs-type">int</span>) &#123;<br>s := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a &#123;<br>s += v<br><span class="hljs-keyword">if</span> s*to &lt;= <span class="hljs-number">0</span> &#123;<br>res += abs(s - to)<br>s = to<br>&#125;<br>to *= <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br>Print(min(f(<span class="hljs-number">1</span>), f(<span class="hljs-number">-1</span>)))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-keyword">return</span> -x &#125;; <span class="hljs-keyword">return</span> x &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> b &#125;; <span class="hljs-keyword">return</span> a &#125;<br></code></pre></td></tr></table></figure></details>]]></content>
    
    
    <categories>
      
      <category>每日一茶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC.1687从仓库到码头运输箱子</title>
    <link href="/2022/12/06/LC-1687%E4%BB%8E%E4%BB%93%E5%BA%93%E5%88%B0%E7%A0%81%E5%A4%B4%E8%BF%90%E8%BE%93%E7%AE%B1%E5%AD%90/"/>
    <url>/2022/12/06/LC-1687%E4%BB%8E%E4%BB%93%E5%BA%93%E5%88%B0%E7%A0%81%E5%A4%B4%E8%BF%90%E8%BE%93%E7%AE%B1%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p><a href="https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/description/">题目链接</a> | <a href="https://leetcode.cn/contest/biweekly-contest-41">第 41 场双周赛</a> | <a href="https://leetcode.cn/contest/biweekly-contest-41/problems/delivering-boxes-from-storage-to-ports/">Q4</a> | 难度:2610</p>          </div><details >  <summary>题目描述</summary><p>你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 <strong>箱子数目的限制</strong> 和 <strong>总重量的限制</strong> 。</p><p>给你一个箱子数组 <code>boxes</code> 和三个整数 <code>portsCount</code>, <code>maxBoxes</code> 和 <code>maxWeight</code> ，其中 <code>boxes[i] = [ports<sub>​​i</sub>​, weight<sub>i</sub>]</code> 。</p><ul>    <li><code>ports<sub>​​i</sub></code> 表示第 <code>i</code> 个箱子需要送达的码头， <code>weights<sub>i</sub></code> 是第 <code>i</code> 个箱子的重量。</li>    <li><code>portsCount</code> 是码头的数目。</li>    <li><code>maxBoxes</code> 和 <code>maxWeight</code> 分别是卡车每趟运输箱子数目和重量的限制。</li></ul><p>箱子需要按照 <strong>数组顺序</strong> 运输，同时每次运输需要遵循以下步骤：</p><ul>    <li>卡车从 <code>boxes</code> 队列中按顺序取出若干个箱子，但不能违反 <code>maxBoxes</code> 和 <code>maxWeight</code> 限制。</li>    <li>对于在卡车上的箱子，我们需要 <strong>按顺序</strong> 处理它们，卡车会通过 <strong>一趟行程</strong> 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 <strong>额外行程</strong> ，箱子也会立马被卸货。</li>    <li>卡车上所有箱子都被卸货后，卡车需要 <strong>一趟行程</strong> 回到仓库，从箱子队列里再取出一些箱子。</li></ul><p>卡车在将所有箱子运输并卸货后，最后必须回到仓库。</p><p>请你返回将所有箱子送到相应码头的 <b>最少行程</b> 次数。</p><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3<b>输出：</b>4<b>解释：</b>最优策略如下：- 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。所以总行程数为 4 。注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。</pre><p><strong>示例 2：</strong></p><pre><b>输入：</b>boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6<b>输出：</b>6<b>解释：</b>最优策略如下：- 卡车首先运输第一个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。- 卡车运输第二、第三、第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。- 卡车运输第五个箱子，到达码头 3 ，回到仓库，总共 2 趟行程。总行程数为 2 + 2 + 2 = 6 。</pre><p><strong>示例 3：</strong></p><pre><b>输入：</b>boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7<b>输出：</b>6<b>解释：</b>最优策略如下：- 卡车运输第一和第二个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。- 卡车运输第三和第四个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。- 卡车运输第五和第六个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。总行程数为 2 + 2 + 2 = 6 。</pre><p><strong>示例 4：</strong></p><pre><b>输入：</b>boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7<b>输出：</b>14<b>解释：</b>最优策略如下：- 卡车运输第一个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。- 卡车运输第二个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。- 卡车运输第三和第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。- 卡车运输第五个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。- 卡车运输第六和第七个箱子，到达码头 3 ，然后去码头 4 ，然后回到仓库，总共 3 趟行程。- 卡车运输第八和第九个箱子，到达码头 1 ，然后去码头 5 ，然后回到仓库，总共 3 趟行程。总行程数为 2 + 2 + 2 + 2 + 3 + 3 = 14 。</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= boxes.length &lt;= 10<sup>5</sup></code></li>    <li><code>1 &lt;= portsCount, maxBoxes, maxWeight &lt;= 10<sup>5</sup></code></li>    <li><code>1 &lt;= ports<sub>​​i</sub> &lt;= portsCount</code></li>    <li><code>1 &lt;= weights<sub>i</sub> &lt;= maxWeight</code></li></ul></details><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>这道题难度还是蛮大的, 关键点在于想到动态规划并且需要使用手段优化其状态转移方程.</p><p>我们定义$f[i]$为运送前$i$个箱子需要的最小行程数.<br>首先需要想到一个$O(n^2)$的解:<br>$$<br>f[i] &#x3D; min(f[j]+cost(j+1,i))+2<br>$$</p><blockquote><p>意义就是从$i$ 之前找到一个$j$, 在$f[j]$的基础上 在运送$[j+1,i]$的箱子. 当然, $[j+1,i]$需要满足两个限制, 一是数目, 二是重量. 计算数量可以直接使用下标相减, 计算重量可以使用前缀和.</p></blockquote><h3 id="1-如何求cost函数"><a href="#1-如何求cost函数" class="headerlink" title="1.如何求cost函数"></a>1.如何求cost函数</h3><p>我们定义$neg$数组, $neg[i]$代表前$i$个箱子中, 有多少个交替不同量. 比如<code>1112</code>中$neg[3]&#x3D;2$, 因为$1\ne 2$. 这样就可以用前缀和的思想处理$[j+1, i]$的$cost$.<br>$$<br>cost(j+1, i) &#x3D; neg[i] - neg[j+1]<br>$$</p><h3 id="2-如何优化状态转移方程"><a href="#2-如何优化状态转移方程" class="headerlink" title="2.如何优化状态转移方程"></a>2.如何优化状态转移方程</h3><p>把$cost$带入到状态转移方程中</p><!-- f[i] = min(f[j]+neg[i]-neg[j+1])+2\\ --><!-- =min(f[j]-neg[j+1]) + neg[i]+2  --><!-- \begin{array}{l} --><!-- x &= v_0\cos\theta t\\ --><!-- y &= v_0\sin\theta t - \frac{1}{2}gt^2 --><!-- \end{array} --><p>$$<br>\begin{align}<br>f[i]&amp;&#x3D;\min (f[j]+n e g[i]-n e g[j+1])+2 \\<br>    &amp;&#x3D;\min (f[j]-n e g[j+1])+n e g[i]+2<br>\end{align}<br>$$<br><font color=#a64942 size=4>可以发现, 在找$j$的时候,我们可以消掉很多状态转移图中的无用的边, 只需要找到最合适的$j$即可</font></p><p class="note note-success">这个过程可以使用堆/平衡树/单调队列</p><h3 id="3-重新定义-f-的索引"><a href="#3-重新定义-f-的索引" class="headerlink" title="3. 重新定义$f$的索引"></a>3. 重新定义$f$的索引</h3><p>有时候在定义状态转移方程的时候, 可以定义为以 <strong>1.第$i$个元素结尾</strong>, 或者 <strong>2.处理前$i$ 个元素</strong>. 因为索引是从0开始的, 所以上述两种方式是索引相差1. </p><blockquote><p>这里可以有一个比较通用的方式: 能不能不用索引$0$元素. 如果发状态转移的时候, 往前边找$j$, 如果$j$,最少最少是从0开始, 那么可以定义 方式1. 如果$j$可以在往前, 就是可以不用索引$0$元素. 那么只能定义2. 因为索引不能是负数.<br><font color=#a64942 size=4>这里需要定义2. 因为, $j$可以不使用元素0, 即$[0, i]$箱子一次运完</font></p></blockquote><p class="note note-primary">所以f这里定义的是处理前i个箱子</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div>            <input type="checkbox"  checked="checked">堆          </div><div>            <input type="checkbox"  checked="checked">单调队列          </div><div>            <input type="checkbox"  >平衡树          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">boxDelivering</span><span class="hljs-params">(boxes [][]<span class="hljs-type">int</span>, portsCount <span class="hljs-type">int</span>, maxBoxes <span class="hljs-type">int</span>, maxWeight <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(boxes)<br>w := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>neg := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> boxes &#123;<br>w[i+<span class="hljs-number">1</span>] = w[i] + v[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>neg[i] = neg[i<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">if</span> v[<span class="hljs-number">0</span>] != boxes[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] &#123;<br>neg[i]++<br>&#125;<br>&#125;<br>&#125;<br><br>f := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>g := <span class="hljs-built_in">make</span>(hp, <span class="hljs-number">0</span>, n+<span class="hljs-number">1</span>)<br>g = <span class="hljs-built_in">append</span>(g, node&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br><span class="hljs-keyword">for</span> g.Len() &gt; <span class="hljs-number">0</span> &amp;&amp; (i-g[<span class="hljs-number">0</span>].j &gt; maxBoxes || w[i]-w[g[<span class="hljs-number">0</span>].j] &gt; maxWeight) &#123;<br>heap.Pop(&amp;g)<br>&#125;<br>p := g[<span class="hljs-number">0</span>]<br>f[i] = f[p.j] - neg[p.j] + neg[i<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> i &lt; n &#123;<br>heap.Push(&amp;g, node&#123;i, f[i] - neg[i]&#125;)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> f[n]<br>&#125;<br><br><span class="hljs-comment">// 堆模板</span><br><span class="hljs-keyword">type</span> (<br>node <span class="hljs-keyword">struct</span>&#123; j, cost <span class="hljs-type">int</span> &#125;<br>hp   []node<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Len() <span class="hljs-type">int</span>              &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span>    &#123; <span class="hljs-keyword">return</span> h[i].cost &lt; h[j].cost &#125; <span class="hljs-comment">// &gt; means maximum heap</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Swap(i, j <span class="hljs-type">int</span>)         &#123; h[i], h[j] = h[j], h[i] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hp)</span></span> Push(v <span class="hljs-keyword">interface</span>&#123;&#125;)   &#123; *h = <span class="hljs-built_in">append</span>(*h, v.(node)) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hp)</span></span> Pop() (v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; a := *h; *h, v = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>], a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]; <span class="hljs-keyword">return</span> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 单调队列</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">boxDelivering</span><span class="hljs-params">(boxes [][]<span class="hljs-type">int</span>, portsCount <span class="hljs-type">int</span>, maxBoxes <span class="hljs-type">int</span>, maxWeight <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(boxes)<br>w := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>neg := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> boxes &#123;<br>w[i+<span class="hljs-number">1</span>] = w[i] + v[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>neg[i] = neg[i<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">if</span> v[<span class="hljs-number">0</span>] != boxes[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] &#123;<br>neg[i]++<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123; j, cost <span class="hljs-type">int</span> &#125;<br>f := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>g := <span class="hljs-built_in">make</span>([]pair, <span class="hljs-number">1</span>, n) <span class="hljs-comment">// &#123;0, 0&#125; is inqueued</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(g) &gt; <span class="hljs-number">0</span> &amp;&amp; (i-g[<span class="hljs-number">0</span>].j &gt; maxBoxes || w[i]-w[g[<span class="hljs-number">0</span>].j] &gt; maxWeight) &#123;<br>g = g[<span class="hljs-number">1</span>:]<br>&#125;<br>p := g[<span class="hljs-number">0</span>]<br>f[i] = f[p.j] - neg[p.j] + neg[i<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> i &lt; n &amp;&amp; <span class="hljs-built_in">len</span>(g) &gt; <span class="hljs-number">0</span> &amp;&amp; g[<span class="hljs-built_in">len</span>(g)<span class="hljs-number">-1</span>].cost &gt;= f[i]-neg[i] &#123;<br>g = g[:<span class="hljs-built_in">len</span>(g)<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-keyword">if</span> i &lt; n &#123;<br>g = <span class="hljs-built_in">append</span>(g, pair&#123;i, f[i] - neg[i]&#125;)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> f[n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p class="note note-info">堆优化可能比较无脑, 在比赛时, 可以优先考虑</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github如何提交PR</title>
    <link href="/2022/12/05/Github%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4PR/"/>
    <url>/2022/12/05/Github%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4PR/</url>
    
    <content type="html"><![CDATA[<p>有时候需要给一些开源项目提交补丁, 需要在Github上提交PR, 那么如何给开源项目提交PR呢?<br>假设 在Github上的项目名字为 <code>Project(remote)</code>.</p><ol><li>我们首先要<strong>fork</strong> 这个<code>Project(remote)</code>到自己的项目中<code>Project(my)</code>.</li><li>在自己的项目下clone到本地<code>Project(my)</code>.</li><li>配置git的upstream 到 <code>Project(remote)</code>. <code>git remote add upstream &lt;remote git&gt;</code></li><li>修改<code>Project(my)</code>, 最终合并到<code>master(my)</code>分支.</li><li><code>git push origin master</code> push到 <code>Project(my)</code>.</li><li>在Github <code>Project(my)</code>下找到Pull requests. 点击 <code>New pull request</code></li><li>会出现<code>diff</code>界面, 然后提交PR, 那么在<code>Project(remote)</code> 就可以看到了.</li></ol><p>需要注意:</p><p class="note note-warning">必须fork到自己的项目下进行修改</p><p class="note note-warning">必须在自己的project下提交PR, 因为设置了upstream, 两个项目关联起来了</p><div style="text-align: center"><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20221205152521.png" width=70% /></div><hr><p>如果<strong>upstream</strong>的<strong>master</strong>分支有了新的提交, 那么需要先把<strong>upstream</strong>的提交<strong>fork</strong>到自己的仓库下:<br><code>git checkout master</code> -&gt; <code>git pull upstream/master</code>&#x2F; <code>git fetch upstream/master + git merge upstream/master</code>-&gt; <code>git push origin master</code> </p><blockquote><p>这样自己的仓库是已经是和upstream一致了. 那么在<code>develop</code>分支 <span class="label label-primary">rebase</span> 一下自己的<code>master</code> 分支.<br>在开发时尽量使用<span class="label label-primary">rebase</span>, 让提交记录整洁一点. 这样提PR的时候, 项目管理者也很好<strong>merge</strong>代码.</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux解决clangd找不到c++头文件问题</title>
    <link href="/2022/12/03/linux-%E8%A7%A3%E5%86%B3clangd%E6%89%BE%E4%B8%8D%E5%88%B0c-%E5%A4%B4%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2022/12/03/linux-%E8%A7%A3%E5%86%B3clangd%E6%89%BE%E4%B8%8D%E5%88%B0c-%E5%A4%B4%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="使用nvim配置c-lsp-server"><a href="#使用nvim配置c-lsp-server" class="headerlink" title="使用nvim配置c++ lsp server"></a>使用nvim配置c++ lsp server</h2><p>对<code>c++</code>的lsp server, 大多是使用<code>clangd</code>. 但是对于有些系统它可能只能找到c语言的头文件而找不到c++的头文件.<br>这个问题可能是由于一些问题造成的, 首先检查lspconfig配置:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim">nvim_lsp[<span class="hljs-string">&#x27;clangd&#x27;</span>].setup(&#123;<br>    on_attach = on_attach,<br>    capabilities = capabilities,<br>    cmd = &#123;<br>        <span class="hljs-string">&quot;clangd&quot;</span>,<br>        <span class="hljs-string">&quot;--query-driver=/usr/bin/g++&quot;</span>,<br>        <span class="hljs-string">&quot;--background-index&quot;</span>,<br>        <span class="hljs-string">&quot;--log=verbose&quot;</span><br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>加上 <code>--query-driver</code>, 尝试解决一下, 并且使用 <code>--log=verbose</code> 进行详细的日至输出.</p><h2 id="针对项目级c-项目"><a href="#针对项目级c-项目" class="headerlink" title="针对项目级c++项目"></a>针对项目级c++项目</h2><p>项目级c++项目可能需要配置<code>compile_commands.json</code> 文件.<br>因为我对c++的需求不大, 仅仅需要clangd对单个cpp文件可以进行lsp service. 所以, 配置<code>compile_commands.json</code> 需要自行查看文档. <a href="https://clangd.llvm.org/troubleshooting#cant-find-standard-library-headers-map-stdioh-etc">文档链接</a></p><h2 id="gcc-或-linux升级引起问题"><a href="#gcc-或-linux升级引起问题" class="headerlink" title="gcc 或 linux升级引起问题"></a>gcc 或 linux升级引起问题</h2><p>如果之前的版本可以, 更新linux后, clangd找不到c++文件. 或者, 某一个低版本gcc可以找到, 最新版本的gcc找不到. 那么极有可能是因为新版本的gcc没有装<code>libstdc++.a</code>文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">╰─&gt;$ clang++ -c ./main.cpp -v<br>Ubuntu clang version 14.0.0-1ubuntu1<br>Target: x86_64-pc-linux-gnu<br>Thread model: posix<br>InstalledDir: /usr/bin<br>Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/11<br>Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12<br>Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12<br>Candidate multilib: .;@m64<br>Selected multilib: .;@m64<br> (in-process)<br> <span class="hljs-string">&quot;/usr/lib/llvm-14/bin/clang&quot;</span> -cc1 -triple x86_64-pc-linux-gnu -emit-obj -mrelax-all --mrelax-relocations -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name main.cpp -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/oliver/code/c++/tmp -resource-dir /usr/lib/llvm-14/lib/clang/14.0.0 -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../include/c++ -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../include/c++/x86_64-linux-gnu -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../include/c++/backward -internal-isystem /usr/lib/llvm-14/lib/clang/14.0.0/include -internal-isystem /usr/local/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -fdeprecated-macro -fdebug-compilation-dir=/home/oliver/code/c++/tmp -ferror-limit 19 -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o main.o -x c++ ./main.cpp<br>clang -cc1 version 14.0.0 based upon LLVM 14.0.0 default target x86_64-pc-linux-gnu<br>ignoring nonexistent directory <span class="hljs-string">&quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../include/c++/x86_64-linux-gnu&quot;</span><br>ignoring nonexistent directory <span class="hljs-string">&quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../include/c++/backward&quot;</span><br>ignoring nonexistent directory <span class="hljs-string">&quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/include&quot;</span><br>ignoring nonexistent directory <span class="hljs-string">&quot;/include&quot;</span><br><span class="hljs-comment">#include &quot;...&quot; search starts here:</span><br><span class="hljs-comment">#include &lt;...&gt; search starts here:</span><br> /usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../include/c++<br> /usr/lib/llvm-14/lib/clang/14.0.0/include<br> /usr/local/include<br> /usr/include/x86_64-linux-gnu<br> /usr/include<br>End of search list.<br>./main.cpp:2:10: fatal error: <span class="hljs-string">&#x27;algorithm&#x27;</span> file not found<br></code></pre></td></tr></table></figure><p>可以发现, 有两个版本的gcc 11 &#x2F; 12, 默认会选择最新的.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">Found candidate GCC installation: <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/gcc/</span>x86_64-linux-gnu/<span class="hljs-number">11</span><br>Found candidate GCC installation: <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/gcc/</span>x86_64-linux-gnu/<span class="hljs-number">12</span><br>Selected GCC installation: <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/gcc/</span>x86_64-linux-gnu/<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>问题就在于, 最新的版本中可能没有装c++的链接库,</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">ignoring</span> nonexistent directory <span class="hljs-string">&quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../include/c++/x86_64-linux-gnu&quot;</span><br><span class="hljs-keyword">ignoring</span> nonexistent directory <span class="hljs-string">&quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../include/c++/backward&quot;</span><br><span class="hljs-keyword">ignoring</span> nonexistent directory <span class="hljs-string">&quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/12/../../../../x86_64-linux-gnu/include&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>问题解决: 安装<code>libstdc++-12-dev</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install libstdc++-12-dev<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>nvim-lsp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一茶:D-11</title>
    <link href="/2022/12/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%8C%B6-D-11/"/>
    <url>/2022/12/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E8%8C%B6-D-11/</url>
    
    <content type="html"><![CDATA[<p>题目链接: <a href="https://atcoder.jp/contests/abc066/tasks/arc077_b">Atcoder</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入 <span class="hljs-built_in">n</span>(<span class="hljs-comment">≤1e5</span>) 和一个长为 <span class="hljs-built_in">n</span>+<span class="hljs-number">1</span> 的数组 a，元素范围 [<span class="hljs-number">1</span>,<span class="hljs-built_in">n</span>]，且 [<span class="hljs-number">1</span>,<span class="hljs-built_in">n</span>] 的每个数都在 a 中。<br>对每个 [<span class="hljs-number">1</span>,<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>] 的 k，输出有多少个长为 k 的不同子序列，模 <span class="hljs-number">1</span>e9+<span class="hljs-number">7</span>。<br>注：下标不同但内容相同的子序列，算相同的子序列。<br></code></pre></td></tr></table></figure><p>输入:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">n <br><span class="hljs-built_in">a1</span> <span class="hljs-built_in">a2</span> <span class="hljs-built_in">a3</span> ... an+<span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>输出:<br>输出n+1行, 第k行代表包含k个元素的不同的子序列, 需要取模</p><p>样例:<br>Sample Input 1 </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Sample Output 1 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>5<br>4<br>1<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一步步进行分析:</p><ol><li>如果没有重复元素, 那么每行答案就是 $C_{n+1}^k$.</li><li>包含一个重复元素, 会对答案产生多少影响.</li><li>如何使用减法原理, 减去重复的子序列.</li></ol><p><img src="https://raw.githubusercontent.com/OliverChao/blog-pic/master/20221203162128.png"></p><p>我们可以发现, 只有在$i$ 左边 和 $j$ 右边的元素可能会对答案产生影响. 共有 $m&#x3D;i+n-j$ 个元素.<br>假如我们选择 $k$ 个元素, 其中一个是选择到了 重复的元素$r$, 那么剩下的$k-1$个元素如果出自$m$个元素中,那就是需要减去的. 答案就是$C_{n+1}^{k}-C_{m}^{k-1}$</p><h2 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h2><p>这里的数据范围很大, 求组合数需要用到模乘逆元进行求解.<br>模板参考<a href="https://github.com/EndlessCheng/codeforces-go/blob/master/copypasta/math.go#L2166">灵茶</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">const</span> mod <span class="hljs-type">int64</span> = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span> <br><span class="hljs-keyword">const</span> mx <span class="hljs-type">int</span> = <span class="hljs-number">1e6</span>     <span class="hljs-comment">// max length</span><br>F := [mx + <span class="hljs-number">1</span>]<span class="hljs-type">int64</span>&#123;<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= mx; i++ &#123;<br>    F[i] = F[i<span class="hljs-number">-1</span>] * <span class="hljs-type">int64</span>(i) % mod<br>&#125;<br>pow := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, n <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    <span class="hljs-comment">// x %= mod</span><br>    res := <span class="hljs-type">int64</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n &gt;&gt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">if</span> n&amp;<span class="hljs-number">1</span> == <span class="hljs-number">1</span> &#123;<br>            res = res * x % mod<br>        &#125;<br>        x = x * x % mod<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br>invF := [...]<span class="hljs-type">int64</span>&#123;mx: pow(F[mx], mod<span class="hljs-number">-2</span>)&#125;<br><span class="hljs-keyword">for</span> i := mx; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>    invF[i<span class="hljs-number">-1</span>] = invF[i] * <span class="hljs-type">int64</span>(i) % mod<br>&#125;<br><span class="hljs-comment">// 求组合数 C(n, k)</span><br>C := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    <span class="hljs-keyword">if</span> k &lt; <span class="hljs-number">0</span> || k &gt; n &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> F[n] * invF[k] % mod * invF[n-k] % mod<br>&#125;<br><span class="hljs-comment">// 求排列数 P(n, k)</span><br>P := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    <span class="hljs-keyword">if</span> k &lt; <span class="hljs-number">0</span> || k &gt; n &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> F[n] * invF[n-k] % mod<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><details>  <summary>Golang 代码</summary>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br>. <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> MOD <span class="hljs-type">int</span> = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(_r io.Reader, _w io.Writer)</span></span> &#123;<br>in := bufio.NewReader(_r)<br>out := bufio.NewWriter(_w)<br><span class="hljs-keyword">defer</span> out.Flush()<br><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>Fscan(in, &amp;n)<br>    <span class="hljs-comment">// 重复元素 r 的下边, 分别是 i 和 j</span><br><span class="hljs-keyword">var</span> i, j <span class="hljs-type">int</span><br>cnt := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> cnt &#123;<br>cnt[i] = <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt;= n; k++ &#123;<br>Fscan(in, &amp;a)<br><span class="hljs-keyword">if</span> cnt[a<span class="hljs-number">-1</span>] != <span class="hljs-number">-1</span> &#123;<br>i, j = cnt[a<span class="hljs-number">-1</span>], k<br><span class="hljs-keyword">break</span><br>&#125;<br>cnt[a<span class="hljs-number">-1</span>] = k<br>&#125;<br><br>    <span class="hljs-comment">// 求组合数, 使用逆元 模板</span><br><span class="hljs-keyword">const</span> mod <span class="hljs-type">int</span> = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span><br><span class="hljs-keyword">const</span> mx <span class="hljs-type">int</span> = <span class="hljs-number">2e5</span> <span class="hljs-comment">// max length</span><br>F := [mx + <span class="hljs-number">1</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= mx; i++ &#123;<br>F[i] = F[i<span class="hljs-number">-1</span>] * <span class="hljs-type">int</span>(i) % mod<br>&#125;<br>pow := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// x %= mod</span><br>res := <span class="hljs-type">int</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n &gt;&gt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">if</span> n&amp;<span class="hljs-number">1</span> == <span class="hljs-number">1</span> &#123;<br>res = res * x % mod<br>&#125;<br>x = x * x % mod<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br>invF := [...]<span class="hljs-type">int</span>&#123;mx: pow(F[mx], mod<span class="hljs-number">-2</span>)&#125;<br><span class="hljs-keyword">for</span> i := mx; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>invF[i<span class="hljs-number">-1</span>] = invF[i] * <span class="hljs-type">int</span>(i) % mod<br>&#125;<br><span class="hljs-comment">// 求组合数 C(n, k)</span><br>C := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> k &lt; <span class="hljs-number">0</span> || k &gt; n &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> F[n] * invF[k] % mod * invF[n-k] % mod<br>&#125;<br>    <span class="hljs-comment">// =================================================</span><br><br><span class="hljs-keyword">for</span> k := <span class="hljs-number">1</span>; k &lt;= n+<span class="hljs-number">1</span>; k++ &#123;<br><span class="hljs-keyword">if</span> k<span class="hljs-number">-1</span> &lt;= i+n-j &#123;<br>Fprintln(out, (C(n+<span class="hljs-number">1</span>, k)-C(i+n-j, k<span class="hljs-number">-1</span>)+MOD)%MOD)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Fprintln(out, (C(n+<span class="hljs-number">1</span>, k)+MOD)%MOD)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>run(os.Stdin, os.Stdout)<br>&#125;<br></code></pre></td></tr></table></figure></details>]]></content>
    
    
    <categories>
      
      <category>每日一茶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
